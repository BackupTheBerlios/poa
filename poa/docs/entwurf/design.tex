%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Entwurf
%% $Id: design.tex,v 1.12 2004/06/15 07:33:58 keulsn Exp $
%% Achtung: Diese Datei wird in den Entwurf inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Architektur}

\section{Übersicht}

Die Architektur von POA gliedert sich in stark zusammenhängende
Module, die durch schmale Schnittstellen miteinander kommunizieren und
so eine geringe Kopplung aufweisen. So kann jedes dieser Module
einzeln an geänderte Anforderungen angepasst werden, wobei die
Interoperabilität erhalten bleibt.

Auf diese Weise wird die größtmögliche Flexibilität für die
Weiterentwicklung und Wartung der Software sichergestellt. Aufgrund
des forschungsnahen Charakters des OA-Projekts wurde auf die
Flexibilität der Architektur besonderer Wert gelegt.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{../abschlussbericht/design}
  \caption{POA Architektur}\label{arch_grafik}
\end{figure}

In Abbildung \ref{arch_grafik} werden die Module von POA
dargestellt. Im Folgenden wird eine kurze Beschreibung gegeben,
Details folgen im Kapitel \ref{modules}.

Die grün dargestellten Module bilden die Basis des
POA-Systems. Entwürfe für Regler auf dem Offenen Antrieb werden in
Projekten (\ref{project}) entwickelt. Die Daten eines Projekts werden
in den Models (\ref{model}) des Projekts gespeichert.

Die rot dargestellten Module, Problemmanager (\ref{problem_manager}),
Scheduling (\ref{scheduling}) und Download (\ref{download}) bilden die
wesentlichen Aufgaben von POA ab.
\begin{itemize}
\item Prüfen der Integrität eines Projekts und Anzeige der
aufgefundenen Problem.
\item Automatische Berechnung eines optimalen Schedulings für das
Netzwerk von Blöcken.
\item Compilation des Sourcecodes und Download auf die spezifizierten
CPUs
\end{itemize}

Die in blau eingefärbten Module realisieren die
Benutzungsschnittstelle von POA. Das Modul GUI umfasst Klassen zur
Darstellung von Dialogen. Die Views (\ref{view}) visualisieren die
relevanten Nutzdaten und das Routing-Modul (\ref{routing}) wird eingesetzt, um
Konnektoren überkreuzungsarm in ein Netzwerk einzubringen.

Schließlich bietet das Utils Modul diverse Funktionalität, die häuftig
benötigt wird. Die Klassen dieses Moduls sind Kandidaten um in
folgenden Projekten wiederverwendet zu werden.

\subsection{Projekte in POA}

Um mehrere Konfigurationen des Offenen Antriebs bearbeiten zu können,
stellt POA das Projekt-Konzept zur Verfügung. Die Arbeit an einer
bestimmten Konfiguration (alle Blöcke, Konnektoren, Source Code,
Layout der Darstellungen) wird in ein Projekt
zusammengefasst. Projekte können als ganzes auf ständigen Speicher
gespeichert und von diesem geladen werden.

Aufgrund ihrer zentralen Stellung bietet die Sicht auf ein Projekt
ebenfalls einen guten Ausgangspunkt für die Betrachtung der
Architektur. (siehe auch \ref{project})

\subsection{Speicherung von Projekten}

Projekte werden in einem Projekt-Ordner auf der Festplatte
gespeichert. Der Name des Ordners ist gleichzeitig der Name des
Projekts. Der Projekt-Ordner enthält die Datei project.xml, die alle
Projekt-Daten enthält.

Zusätzlich gibt es für jede CPU des Projekts einen Unter-Ordner, der
die wiederum die Ordner inc für zu inkludierende
C-Präprozessor-Definitionen oder C-Deklarationen, lib für Bibliotheken
gegen die der selbstgeschriebene Code zu linken ist, und src für den
Quelltext für die CPU enthält. Für diesen Quelltext kann POA
Rahmencode generieren.

\section{Entwurfsmuster}

Der Entwurf von POA integriert bekannte und weitverbreitete
Entwurfsmuster, um die Struktur des Entwurfs leicht verständlich zu
machen und für zukünftige Erweiterungen im größtmöglichen Maße offen
zu sein.

Entwufsmuster beschreiben eine Lösungsstrategie für ein abstraktes
Problem. Die Struktur des Codes wird so weitgehend standardisiert und
ermöglicht einem Wartungsingenieur eine schnelle
Einarbeitung. Weiterhin bieten sie Richtlinien an, wie weitere
Funktionalität in das System integriert werden kann.

\subsection{Model-View-Controller}
\label{model_view_controller}

In dem Model-View-Controller Entwurfsmuster wird die Verarbeitung der
Daten vollständig von der Visualisierung unabhängig gehalten. Die
Daten werden in sogenannten Model Klassen verwaltet und von View
Klassen angezeigt, wobei eine 1:n Beziehung besteht, das heißt mehrere
Views können die selben Daten darstellen. Es werden auch verschiedene
Ansichten auf die selben Daten ermöglicht. Die Kommunikation von
Model- zu View-Klassen erfolgt anonym über Benachrichtigungen (siehe
auch \ref{Benachrichtigungen}).

Eine Model Klasse stellt über get-Methoden oder Iteratoren den Zustand
zur Verfügung. Dieser Zustand wird von einer View-Klasse dem
Anwendungszweck entsprechend angezeigt. Konkret werden die Blöcke,
Pins und Verbindungen in POA jeweils durch Datenobjekte
repräsentiert. Diese werden mit Hilfe von entsprechenden Viewobjekten von der
GridCanvas Klasse angezeigt. 

\subsection{Observer}

Die QT Bibliothek erweitert den Sprachumfang von C++ über einen
speziellen Compiler, den Meta-Object-Compiler (MOC), mit einem
Benachrichtigungskonzept. Mit Hilfe von
Benachrichtigungen können Objekte anderen Objekten Mitteilungen über
Zustandsänderungen schicken. Die nahtlose Integration in die
Programmiersprache ermöglicht eine besonders einfache Verwendung des
Mechanismus.

\label{Benachrichtigungen}
Die Benachrichtigungen (Signals) werden durch das Schlüsselwort emit
gesendet und von speziellen Methoden (Slots) empfangen. Die Signals
und Slots werden in den Klassendeklarationen angegeben. Die Verbindung
zwischen zwei Objekten wird mittels der connect Methode hergestellt. 

In POA wird an mehreren Stellen Gebrauch von dem Signal-Slot
Mechanismus gemacht: 
\begin{enumerate}
\item Wenn sich Einstellungen verändern 
\item Wenn ein Projekt verändert wurde
\item Um die Kommunikation zwischen Pins und den zugehörigen Blöcken
und Konnektoren zu ermöglichen.
\item Um Veränderungen zwischen Models und Views zu synchronisieren.
\end{enumerate}

\subsection{Strategie}

Das Strategiemuster ermöglicht, den Algorithmus für eine Problemlösung
austauschbar zu machen. 

In POA wurde die Routing Schnittstelle für die Verbindungen zwischen
den Blöcken abstrakt definiert und konkret mit zwei verschiedenen
Algorithmen implementiert. Die Algorithmen haben unterschiedliche
Eigenschaften in Bezug auf die Laufzeit und Qualität des Ergebnisses. 

\subsection{Singleton}

Das Singleton Muster wird verwendet, wenn eine Klasse nur genau einmal
instanziert werden soll. Dadurch lassen sich auch in
objekt-orientierten Systemen, äquivalent zu globalen Variablen in
imperativen Systemen, global verfügbare Objekte realisieren,
die über eine definierte Schnittstelle angesprochen werden können. 

In POA ist lediglich die Settings Klasse als Singleton implementiert.

\section{Module}
\label{modules}

Die Architektur von POA lässt sich in stark zusammenhängende
Module aufteilen, die eine gerine Kopplung aufweisen. In den folgenden
Abschnitten sind diese Module im Detail beschrieben.

Die Zuordnung von einzelnen Klassen zu Modulen lässt sich in der Regel
aus dem Klassennamen ableiten oder ist aus dem POA
Software-Architektur anhand der Schattierung ersichtlich.

\subsection{Datenmodell (Model)}
\label{model}

In den Model-Klassen wird das Datenmodell eines Projekts
repräsentiert. In POA werden Daten in Objekten der Klassen BlockModel
und PinModel, sowie abgeleiteter Klassen gespeichert. Die Klasse
Projekt stellt den Zusammenhalt zwischen den einzelnen Models her.

\subsection{View}
\label{view}

Views werden verwendet, um dem Benutzer die Daten zu präsentieren. Sie
werden über Signals benachrichtigt, wenn sich ein Model verändert und
passen dann die grafische Darstellung entsprechend an.

Der GridCanvas ist eine Arbeitsoberfläche für ein POA-Netzwerk. Die
Basisklasse für den GridCanvas sowie für alle Views darauf werden von
der QT-Bibliothek gestellt. Für POA musste nur eine Spezialisierung
dieser Basisfunktionalität durchgeführt werden.

Ohne selbst als Model gelten zu können, stellt der GridCanvas nur eine
virtuelle Arbeitsoberfläche dar. Für die Darstellung eines Teils des
GridCanvas sind CanvasView-Objekte zuständig. So kann dieselbe
Arbeitsoberfläche in mehreren Fenstern geöffnet werden und in jedem
Fenster kann ein anderer Ausschnitt der Arbeitsoberfläche angezeit
werden.

Die meisten Views, die speziell für POA entwickelt wurden, päsentieren
grafische Objekte auf einem dem GridCanvas. Dazu gehören BlockView,
PinView und TextView.

Eine besondere Behandlung ist allerdings für Konnektoren
notwendig. Konnektoren können auf dem Canvas nicht ohne weiteres
dargestellt werden, weil Qt seine Funktionalität hier auf wenige
geometrische Objekte beschränkt. Die Linienzüge die In POA verwendet
werden, bestehen deshalb aus mehreren
ConnectorViewSegment-Objekten. Um von der Verwaltung der einzelnen
Segmente zu abstrahieren wurde die Klasse ConnectorViewList
eingeführt. Objekte dieser Klasse agieren als View für ein
ConnectorModel, aber delegieren die tatsächliche Darstellungsaufgabe
an mehrere ConnectorViewSegment-Objekte.

\subsection{Controller}
\label{controller}

Als Controller wird die Komponente bezeichnet, die Benutzereingaben
und interne Ereignisse verarbeitet und die Synchronisation zwischen
View und Model sicherstellt.

Aktionen, die der Benutzer durch Eingaben anstößt, lösen in QT Signals
aus. Diese Signals werden in POA lokal in dem entsprechenden
View-Objekt verarbeitet, z.B. in CanvasView für alle Aktionen, die auf
dem Canvas geschehen (z.B. Selektieren eines Blocks) oder in
MainWindow (z.B. bei Aktivieren eines Menüpunkts). Aufwändige
Bearbeitungen werden in spezielle Action-Objekte ausgelagert.

Eine Besondere Auslagerung der Controller bietet sich für POA nicht
an. Die Benutzer-Eingaben erfolgen auf einer bestimmten View und das
zugehörige View-Objekt hat die nötigen Kompetenzen, um die Eingabe zu
verarbeiten. Falls eine Bearbeitung mehrere Schritte erfordert, so
erzeugt das View-Objekt ein Action-Objekt, um die Aufgabe zu
erledigen.

\subsection{Project}
\label{project}

Die Daten, die in POA zum Layout eines Netzwerks gehören, werden in
einem Objekt der Klasse Project registriert. Das Project-Objekt
übernimmt die administrativen Aufgaben beim Laden und
Speichern. Außerdem verwaltet es die Canvases, auf denen die Views
leben.

\subsection{Scheduling}
\label{scheduling}

Optimales Scheduling bedeutet in POA die Berechnung eines optimalen
Offsets für jeden Block, da die Taktraten für jeden Block bereits
feststehen.

Die optimalen Offsets werden in POA für bestimmte Signalpfade
berechnet. Hierzu dient dienen Objekte der Klasse Path. Für jeden
gewünschten Signallaufpfad wird ein solches Objekt erzeugt. Dann kann
die Signallaufzeit minimiert werden, indem alle Path-Objekte in einer
definierten Reihenfolge einzeln optimiert werden.

Die Path-Objekte verwenden dazu eine Graph-Struktur, die von der
Klasse Blockgraph angeboten wird. Ein BlockGraph besteht aus einer
Reihe von BlockNode-Objekten. In den BlockNode-Objekten kann ein Flag
gesetzt werden. Anhand dieses Flags erkennt der
Optimierungsalgorithmus, ob ein bestimmter Knoten bereits einen
optimalen Offset erhalten hat, oder noch verändert werden darf.

Eine Auswahl von Signallaufpfaden, kann der Benutzer in dem
AutoSchedulingDialog vornehmen. Dieser Dialog bedient sich des
BlockGraphs, um eine Liste aller Blöcke anzuzeigen, die noch in keinem
Pfad enthalten sind.

\subsection{Download}
\label{download}

Der Download ist in der Klasse DownloadManager implementiert. Zur
Übertragung der Daten wird die QExtSerialPort Bibliothek verwendet.
Die Bibliothek einheitliche Methoden zum Zugriff auf die serielle
Schnittstelle für Windows und Linux. Die Initialisierung erfolgt in
der initializeAndOpen() Methode. Hier können die fest programmierten
Übertragungsparameter und die Geschwindigkeit geändert werden. Die
Übertragung der Daten erfolgt in der download() Methode und kann hier
angepasst werden, falls sich das Übertragungsprotokoll ändert.
 
\subsection{Routing}
\label{routing}

Die Routing Schnittstelle ist sehr abstrakt definiert. Es wird
lediglich die Verbindung zweier Punkte auf einem GridCanvas gefordert.
Zwei Routing Algorithmen mit sehr unterschiedlichen Eigenschaften
implementieren diese Schnittstelle.

Der DirectRouter stellt die Verbindung anhand von Fallunterscheidungen
mit der geringsten Anzahl von Knickpunkten her ohne Überschneidungen
zu berücksichtigen. Der Algorithmus ist ausreichend schnell, um die
Verbindungen während des Verschiebens von Blöcken simultan
neuzuberechnen. 

Der Dijkstrarouter benutzt den Dijkstra Algorithmus um eine optimale
Route mit möglichst wenig Knickpunkten und Überschneidungen zu finden.
Auf Grund der Vielzahl der möglichen Wege beträgt die Laufzeit des
Algorithmus in der Regel ein vielfaches des DirectRouter.

Durch Ableitung der ConnectorRouter Klasse und Erweiterung der
GridCanvas Klasse ist jederzeit eine Implementierung von zusätzlichen
Routing Algorithmen möglich. 

\subsection{Problemmanager}
\label{problem_manager}

Die Klasse ProblemReportManager validiert ein Projekt und stellt eine
Baumansicht mit den Ergebnissen zur Verfügung. Im ersten Schritt
werden alle Blöcke sequentiell geprüft. Im zweiten Schritt werden die
Verbindungen zwischen den Blöcken geprüft. Die Validierung erfolgt in
der report() Methode und checkBlock() Methode. Hier können weitere
Prüfungen eingefügt werden. Für jeden Fehler wird ein Objekt vom Typ
ProblemReportItem erzeugt.

\subsection{Querschnittsmodule}

Einige Klassen können keinem Modul zugeordnet werden, da diese von
vielen Modulen benutzt werden. Einige dieser Querschnittsklassen sind
im folgenden beschrieben.

\subsubsection{Einstellungen (Settings)}

In den Settings werden globale Einstellungen wie Farben, Schriftarten
und Pfade verwaltet, die zum Teil auch über den Einstellungsdialog vom
Benutzer geändert werden können. Änderungen von Einstellungen, die
direkt in der Anwendung sichtbar gemacht werden sollen, werden über
entsprechende Signale bekannt gemacht.


%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
