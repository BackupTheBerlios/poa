%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Abschlussbericht
%% $Id: abschlussbericht.tex,v 1.8 2004/05/18 23:03:21 garbeam Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,titlepage,12pt,ngerman]{scrbook}
\usepackage{../common/header}
\RCSdef $Revision: 1.8 $
\RCSdef $Date: 2004/05/18 23:03:21 $

\newcommand\version{Version 1.0 \xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Deckblatt

\begin{titlepage}
\input{../common/logo}
\Huge Abschlussbericht

\setcounter{footnote}{0}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Versionsgeschichte

\section*{Versionsgeschichte}

\begin{itemize}

\item Version 1.0 (xx.05.2004)

  Diese Version wurde dem Auftraggeber vorgelegt.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}

\section{Zweck des Dokuments}

\section{Projektziele}

Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen
gemacht.  Viele dieser Entwicklungen beinhalten neue Kinematiken, wie
z.B. die Parallelkinematiken und Sensoren (z.B. den Ferraris
Relativbeschleunigungssensor).  Dadurch entstehen neue Anforderungen
an die Antriebsregelung. Zus"atzliche Sensor-Signale m"ussen in den
Reglerstrukturen ber"ucksichtigt werden -- oder es werden sogar
v"ollig neue Reglerstrukturen ben"otigt.

Die momentan auf dem Markt erh"altlichen Reglersysteme erlauben meist
weder die Ber"ucksichtigung neuartiger Sensoren, noch bieten sie die
M"oglichkeit, eigene anwenderspezifische Reglerstrukturen zu
implementieren.

Daher wird am ISW eine Plattform f"ur die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene
Funktionalit"aten zu integrieren. Diese Plattform wird am
ISW\footnote{Institut f"ur Steuerungstechnik der Werkzeugmaschinen und
  Fertigungseinrichtungen} an der Universit"at Stuttgart kurz als
``Offener Antrieb'' bezeichnet.

Die hardwaretechnische Realisierung erfolgt in Form einer Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX'' Baustein. Es
handelt sich dabei um ein CPLD\footnote{Complex Programmable Logic Device},
das sich frei programmieren l"asst. Der Anwender hat die M"oglichkeit, die
Funktion des Bausteins seinen Bed"urfnissen anzupassen.

Um die Offenheit f"ur jeden Anwender nutzbar zu machen, wird f"ur das CPLD eine
Architektur festgelegt, die es erm"oglicht, einzelne Funktionalit"aten in Form
von Bl"ocken zu implementieren. Diese Bl"ocke k"onnen aus fest programmierten
Schaltungen (Cores) und freiprogrammierbaren CPUs bestehen. Jedes Block kann
auf die Signale aller anderen Bl"ocke zugreifen und stellt seine eigenen
Ausgangssignale allen anderen Bl"ocken zur Verf"ugung.

POA bietet eine anwenderfreundliche Programmierumgebung f"ur das Netzwerk
von CPUs und Cores, in dem ein bereits auf dem CPLD vorhandenes
Netzwerk konfiguriert werden kann.

\section{Anforderungen}

\section{Entwicklungsphilosophie}

- GPL
- Transparenz

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektergebnisse}

\section{Programmierumgebung Offener Antrieb}
Aus der genannten Aufgabenstellung resultierte POA, die ``Programmierumgebung 
Offener Antrieb''. POA ist eine Applikation mit grafischer Oberfl"ache, in der 
Funktionsbl"ocke (sowohl Cores als auch CPUs) auf einer Arbeitsfl"ache platziert 
und miteinander verbunden werden k"onnen. 

POA hilft nach der Erstellung des Netzwerkes bei der Pr"ufung der Konsistenz, bei 
der Optimierung der zeitlichen Offsets der einzelnen Bl"ocke, bei der Programmierung 
der CPUs sowie bei der "Ubertragung der "ubersetzten Codes auf die CPUs.

\includegraphics[width=15cm]{bspprojekt1}

\subsection{Merkmale}
Im einzelnen bietet POA im Wesentlichen folgende Funktionalit"aten:
\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Bearbeitung einer CPLD-Blockbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung f"ur eingebette CPU-Bl"ocke in einem CPLD-Layout
\item Plausibilit"atspr"ufung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen von Quellcode f"ur die CPU-Bl"ocke
\item Speichern und "Offnen von CPLD-Layouts und zugeh"origem Quellcode
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}

\section{Dokumente}

\subsection{Angebot}
\subsection{Handbuch}
\subsection{Interne Dokumente}

Entwurf, Spezifikation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektorganisation}

\section{Projektrahmen}

Auftraggeber, Auftragnehmer

\section{Das Team}

Das Team bestand aus sieben Studenten der Software-Technik, die zu
Beginn des Projekts im sechsten Semester studierten. 

\begin{itemize}
\item Necati Aydin
\item Anselm Garbe
\item Stefan Hauser
\item Steffen Keul
\item Marcel Kilgus
\item Steffen Pingel
\item Tammo van Lessen
\end{itemize}


\subsection{Rollen}

Formale Rollen wurden mangels Notwendigkeit nur wenige festgelegt. 

\subsubsection{Projektleiter}

Der Projektleiter war für den Kontakt mit dem Kunden und für die
Koordination des Teams zuständig. 

Die Rolle des Projektleiters wurde von Steffen Pingel übernommen.

\subsubsection{Konfiguationsmanager}

Der Konfiguationsmanager war für die Verwaltung des zentralen
Repositories in dem sowohl die Dokumente als auch der Quellcode
gespeichert wurde zuständig. 

Desweiteren wurden vom Konfiguationsmanager Richtlinien zur
Formatierung des Quellcodes und zur Benutzung des Repositories
erstellt. 

Die Rolle des Konfiguationsmanagers wurde von Anselm Garbe übernommen.

\subsubsection{Entwickler}

Die Aufgabe der Entwickler war die Erstellung des Quellcodes und das
Verfassen der Dokumente.

Die Rolle der Entwickler wurde von allen Teilnehmern belegt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektablauf}

\section{Prozessmodell}

Als Prozessmodell wurde ein iteratives Phasenmodell gewählt wobei
nicht alle Phasen in den einzelnen Iterationen ausgeführt wurden. Die
Anforderungsanalyse-, Spezifikations- und Entwurfsphase wurden nur zu
Beginn des Projekts einmalig durchlaufen. Auch ein Gesammttest wurde
nur zum Ende des Projekts ausgeführt. 

Die einzelnen Iterationen, genannt Sprints, bestanden jeweils aus
einer Anforderungsanalyse-, Entwurfs- und Kodierungsphase, die von
einem kontinuierlichen Regressionstest begleitet wurde. Zu Ende jeder
Iteration wurde das weiter entwickelte Produkt ausgeliefert und vom
Kunden einem Akzeptanztest unterzogen. 

Das Prozessmodell wurde gewählt um dem Forschungscharakter des
Projekts gerecht zu werden. Zu Begin des Projekts war unklar wie
stark sich die Anforderungen während des Projekts ändern
würden. Deswegen wurde zu Beginn jeder Iteration

...and here the tale suddenly ended. Which reminds me of this:

\begin{verbatim}
MAYNARD:  It reads, 'Here may be found the last words of Joseph
    of Aramathea.  He who is valiant and pure of spirit may find
    the Holy Grail in the Castle of uuggggggh'.
ARTHUR:  What?
MAYNARD: '... the Castle of uuggggggh'.
BEDEMIR:  What is that?
MAYNARD:  He must have died while carving it.

[Monthy Python and the Holy Grail]
\end{verbatim}

\section{Projektplan}

Der ursprünglich im Angebot vorgesehe Zeitplan diente als grobe
Orientierung für den Projektverlauf. Die Planung und Ausführung war im
wesentlichen von einer Hausmesse am ISW und dem Ablauf der Semesters
geprägt. 

Die ursprünglich geplanten fünf Sprints wurden auf drei Reduziert. Zum
Einen stellte sich während des Projekts heraus, das die Anforderungen
abgesehen von kleinen zusätzlichen funktionalen Anforderungen
weitgehend stabil waren. Zum Anderen war der zeitliche Aufwand,
bedingt durch organisatorische Tätigkeiten wie eine
Produktpräsentation am Ende jedes Sprints höher als erwartet. 

Die vereinbarten Meilensteine wurde eingehalten bzw. im mit dem
Einverständnis des Kunden geringfügig verschoben. 

Als Schwierig erwiess sich die Koordination der individuellen
Wochenpläne. Bedingt durch unterschiedlich gewählte Vorlesungen,
andere Studienprojekte, Urlaubsplanung, Krankheit und
Nebenbeschäftigungen war es kaum möglich gemeinsame Termin zu finden.
Dennoch wurde sowohl während Entwicklung des Prototypen in der
vorlesungsfreien Zeit und während der Sprints in der Vorlesungszeit
Kernarbeitszeiten eingeführt, die die Kommunikation stark erleichtert
haben.

Die Kernarbeitszeiten wurden während des Projekts durch Treffen des
Teams in entspannter Athmosphäre ergänzt. Während der Treffen wurde
von den Teilnehmern über den Fortschritt berichtet und anstehende
Aufgaben verteilt. 

\subsubsection{Ursprünglicher Zeitplan}

\begin {center}
  \begin {tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Termin} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 200 & KW 25 & M1: Angebot \\
     2 & Spezifikation & 300 & & \\
     3 & Entwurf & 300 & & \\
     4 & Prototyp Messe & 300 & 1.10.2003 & M2: Prototyp Messe \\
     5 & Prototyp Erweitert & 300 & 10.11.2003 & M3: Prototyp Erweitert \\
     6 & Sprint 1 & & KW 48 - 51 & \\
     7 & Sprint 2 & & KW 2 - 6 & \\
     8 & Sprint 3 & & KW 8 - 12 & \\
     9 & Auslieferung und Präsentation & & 1.4.2004 & M4: Auslieferung\\
    \hline
       & & 1400\\
  \end {tabular}
\end {center}

\subsubsection{Projektablauf}

\begin {center}
  \begin {tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Termin} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 200 & KW 25 & M1: Angebot \\
     2 & Spezifikation & 300 & & \\
     3 & Entwurf & 300 & & \\
     4 & Prototyp Messe & 300 & 1.10.2003 & M2: Prototyp Messe \\
     6 & Sprint 1 & & KW 48 - 51 & \\
     7 & Sprint 2 & & KW 2 - 6 & \\
     9 & Auslieferung & & 26.3.2004 & M4: Auslieferung\\
     9 & Nachbesserung & & 19.4.2004 & \\
     9 & Abschlusspräsentation & & 1.6.2004 & \\
    \hline
       & & 1400\\
  \end {tabular}
\end {center}

\subsection{Anforderungsanalyse}

Während der Anforderungsanalyse wurde Anforderungen des Kunden
ermittelt. Die Ergebnisse wurden in einem Angebot dokumentiert, das
dem Kunden zur Abnahme vorgelegt wurde. Das Angebot beinhaltete
ausserdem eine Zeitplan und eine Beschreibung des geplanten
Projektablaufs. 

\subsection{Spezifikation}

Die Spezifikation beinhaltete Benutzungsfälle und wurde als internes
Dokument zur Erstellung der Benutzungsoberfläche verwendet.

\subsection{Entwurf}

Im Grobentwurf wurde die Architektur festgelegt und die Schnittstellen
des Datenmodells in Form von Headerdateien entwickelt.

\subsection{Prototyp (Erste Iteration)}

Der Prototyp wurde für eine Hausmesse am ISW entwickelt. Der Prototyp
wurde für die Präsentation des Offenen Antriebs verwendet. Der Focus
lag auf der Entwicklung der graphischen Benutzungsoberfläche, die
teilweise funktionslose Dialoge beinhaltete. 

Die zeitgemässe Auslieferung des Prototypen und die damit verbundene
Erreichung des zweiten Meilensteins war auch ein erster Test, ob die
Umsetzung der Anforderungen mit den Vorstellung des Kunden
übereinstimmte. Da sich die Rückmeldungen des Kunden als sehr positiv
erwies, wurde die Entscheidung getroffen den Prototyp nicht zu
verwerfen sondern als Basis weiter zu verwenden. Somit kann die
Entwicklung des Prototypen als erste Iteration bezeichnet werden. 

\subsection{Zweite Iteration}

Zu Beginn des ersten Sprints wurde ein Refaktorisierung des Quellcodes
vorgenommen, um die während der Entwicklung des Prototypen entdeckten
Schwachstellen des Entwurfs zu beseitigen. 

Desweiteren wurden Funktionalitäten, die im Prototypen nur als Dialoge
zur Verfügung standen implementiert. 

Zum Ende des erstens Sprints wurde das bisher nur unter Linux
entwickelte Produkt auf Microsoft Windows portiert. Neben einigen
syntaktischen Korrekturen, die in Unterschieden zwischen den
verwendeten Compilern begründet sind, mussten kleinere
plattformspezifische Eigenheiten von QT umschifft werden.

Die Portierung, die oben beschriebene Refaktorisierung und die
zweiwöchigen Weihnachtsferiern haben zu der Ausdehnung der Iteration
bis in den Januar geführt. 

\subsection{Dritte Iteration}



\subsection{Auslieferung}

\subsection{GCover Unterprojekt}

\section{Zeitverteilung}

Die Zeitaufwände der einzelnen Entwickler waren homogen verteilt.

\includegraphics[width=15cm]{zeitverteilung}

Bei den Tätigkeiten überwiegt der Anteil der Implementierung. 

\includegraphics[width=15cm]{phasenverteilung}

\section{Werkzeuge}

Für die Entwicklung wurden zahlreiche Werkzeuge eingesetzt. Die Wahl
war den Entwicklern freigestellt solange die vereinbarten Richtlinien
eingehalten wurden. Bei der Wahl von Dokumentenformaten wurde darauf
geachtet, dass für alle eingesetzten Platformen freie Werkzeuge zur
Bearbeitung verfügbar waren.

Besondere Erwähnung soll das Werkzeug Maven finden. Maven wurde für
die Generierung der Projektseite im Internet benutzt. Maven bietet
die Möglichkeit eine anschauliche Projektdokumentation auf einfache
Art und Weise zu erstellen. Die Dokumentation enthält unter anderem
Informationenn über die Entwickler, den Quellcode und die
Projektablauf. Damit konnte sowohl für den Kunden als auch für die
Entwickler eine hohe Transparenz erreicht werden.

Verwaltet wurde das Projekt auf der Open-Source Platform Berlios, die
vom Frauenhofer Institut betrieben wird. Berlios bietet vielfältige
Unterstützung wie z.B. eine Internetseite, einen Downloadbereich,
Mailinglisten und ein Repository. Zu dem Bedauern des Teams ließ die
Verfügbarkeit von Berlios in den letzten Wochen des Projekts stark zu
wünschen übrig und erschwerte so den Informationsaustausch.

Die Tracker Funktionalität von Berlios wurde nicht
benutzt. Stattdessen wurde Jira von Atlassian eingesetzt, die
freundlicherweise eine kostenlose Lizens für das POA Projekt zur
Verfügung stellten. Jira ermöglicht eine detailierte Erfassung von
Aufgaben und Fehlerberichten inklusive einer Zeitabschätzung und
Fortschrittserfassung. Letzters war sehr hilfreich bei der Planung und
Kontrolle der Sprints.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Statistische Analyse}

\section{Versions Kontrolle}

\subsection{Evolution}

\section{Metriken}

\subsection{Testüberdeckung}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Persönliche Berichte}

\section{Necati Aydin}
\section{Anselm Garbe}

Draft :-)

\subsection{Tätigkeiten}
Seit Projektbeginn war ich neben den allgemeinen
Entwicklunstätigkeiten für das Configuration Management verantwortlich,
welches die Aufstellung von Richtlinien zur Toolunterstützung, u.a. zu
CVS, ssh und TeX beinhaltete, sowie die Pflege und Wartung des
Projekt-Repositories und der Mailinglisten. Die Pflege des
Projektrepositories und der Mailinglisten waren eine permanente Aufgabe
bis zum Projektende. Hierzu gehörte u.a. auch die Sicherung von
automatischen Backups zu POA.

Am Projektbeginn war ich an der Spezifikations- und Angebotserstellung
beteiligt, vor allem mit dem Fokus auf die GUI und Codegenerierung.
Grundlage des Angebotes und der Spezifikation war eine detaillierte
Anforderungsanalyse die durch verschiedene Kundengespräche durchgeführt
wurde.

Zusammen mit Steffen Keul erstellte ich einen Grobentwurf, der
grundlegend das MVC Design Pattern propagierte, dass integraler
Bestandteil von POA während der gesamten Entwicklung blieb.

Aufgrund meiner C++ Kenntnisse aus der Zeit vor meinem Studium, die auch
verschiede windows-basierte GUI Anwendungen zur Folge hatten sowie aufgrund
meiner C Kenntnisse aus einem OpenSource Projekt wählte ich als
Seminarthema das ``Qt Toolkit'' welches eine portable OpenSource
Plattform (für nicht-kommerzielle Projekte) bietet, die unter Windows,
Unix und Mac OS X lauffähig ist und dem POA Team einen initialen
Anleitungsfaden vermitteln sollte.

Zu Beginn der Implementierungsphase in der ersten Iteration entwickelte
ich zusammen mit Steffen Pingel eine Qt-basierte POA Rahmenanwendung,
die eine MDI (Multiple Document Interface) Architektur 
sowie den qmake-basierten Buildprozess unterstützte.
Zu dieser Zeit evaluierte ich auch, dass wir auf die
Entwicklungsunterstützung durch den Qt (GUI) Designer verzichten, da
dieser nur absolute Widget-Positionierung unterstützt und 
umständlichen Code generiert - die GUI Entwicklung im POA Projekt fand
weitestgehend ohne Unterstützung des Qt Designers statt bzw. ist in der
Rückbetrachtung vollkommen unabhängig von diesem verlaufen.

Während der Implementierungsphase war ich für die Entwicklung des
Block-Konfigurationsdialoges, sowie des (De)Mux-Konfigurationsdialoges
zuständig, sowie mit der Integration der damit zusammenhängenden Models
(CPU-, Block-, Mux- und PinModel). Darüber hinaus entwickelte ich den
CodeManager für die Konfiguration und Editierung von CPUs. Dieser führt
automatische Substitutionen des Quellcodes durch, der alle Ein- und
Ausgänge (Pins) der CPU-Konfiguration als Variablen (NIOS Address
Pointer) zur Verfügung stellt. Hierzu zählte auch die Entwicklung eines
internen Ausgabeterminals, das Compiler-Ausgaben in einen POA Dialog
umleitet, um den Status und Fortschritt der Compilierung des Quellcodes
einer CPU zur Verfügung stellt.

Neben meiner Entwicklungstätigkeit nahm ich auch an verschiedenen
Reviews des Quellcodes und des Handbuchs teil, die zur
Qualitätssicherung durchgeführt wurden.

\subsection{Beurteilung}

Rückblickend betrachtet verlief die POA Entwicklung ohne nennenswerte
Konflikte im Team. Die Zusammenarbeit mit den anderen Entwicklern war
durchweg harmonisch. Trotz der weitestgehend autonomen
Entwicklertätigkeiten funktionierte die Modulintegration durch kurze
Absprachen sehr gut, mir ist rückblickend fast kein Zeitpunkt bekannt,
an dem die POA Applikation im CVS nicht compilierfähig gewesen wäre.

Ich empfand die durchweg kollegiale und lockere Entwicklerführung durch
den Projektleiter Steffen Pingel als angenehm und motivierend.
Alle Entwickler konnten aufgrund der nur kurzen Kernarbeitszeit ihre
Aufgaben weitestgehnd autonom lösen. Neben der eigentlichen
Entwicklertätigkeit trafen sich die Entwickler auch spontan zu privaten
Arrangements.

Aus ökonomischer Sicht stellt sich mir durch Vergleiche mit
kommerziellen Projekten durch meine werkstudentische Tätigkeit sowie
meines viermonatigen Industrtiepraktikums bei der
Firma Danet IS GmbH in Stuttgart die POA Entwicklung als voller Erfolg
dar, da der Zeitrahmen nicht überzogen wurde und somit sich die Kosten im
Rahmen des für Studienprojekte vorgesehenen Zeitaufwands beliefen.

Das die POA Entwicklung ein voller Erfolg war dürfte vor allem auf die
Team-Zusammensetzung zurückzuführen sein.

\section{Stefan Hauser}
\section{Steffen Keul}
\section{Marcel Kilgus}
\subsection{Aufgaben}
Aufgrund meiner weit über 10 Jahre Erfahrung mit Maschinencode und der Emulation 
von Prozessoren oblag mir das Seminarthema der Laufzeitmessung von Altera NIOS 
CPUs. Dazu wurden verschiedene Verfahren evaluiert, vom einfachen Profiling bis zum 
Schreiben eines kompletten CPU Simulators. Letztendlich sind die Rahmenbedingungen 
einer Ausführung im CPLD aber so vielen Faktoren unterworfen dass dies nicht mit 
vertretbarem Aufwand und vor allem nicht in der benötigten Präzision möglich war. 
Die einzig verbleibende Option einer hardwaregestützten Instrumentierung des Codes 
inklusive Ausführung auf einem realen CPLD konnte im Rahmen des Projekts leider
nicht weiter verfolgt werden.

Der Kunde verlangte von uns primär eine Windows Applikation, mit der Option
später auf Linux wechseln zu können. Zu diesem Zweck wurde die Qt Bibliothek
von Trolltech als Basis für POA bestimmt. POA an sich wurde größtenteils unter 
Linux entwickelt, als einzigem mit Erfahrung in der der Windows Programmierung im 
Team oblag es mir die ``Redmond''\footnote{Für die nicht Eingeweihten: Firmensitz 
der Microsoft Corporation} Kompatibiltät des Codes sicherzustellen. Zuerst wurde 
dies erreicht mit der Hilfe des MinGW Compilers, einem GCC Port für Windows. Da 
aber nur Microsoft Visual C++ offiziell von Trolltech für Windows unterstützt 
wird und dieser Compiler auch noch andere Vorteile mit sich bringt (IDE mit 
integriertem Debugger, schnellerer Übersetzer, kompakterer Code), lag es an 
mir die Unterschiede der beiden Compiler zu bestimmen und den vorhandenen 
Code in einer Art anzupassen, die auf beiden Plattformen lauffähig ist.

Auch im weiteren Verlauf der Entwicklung habe ich neue Codeblöcke und Code
Änderungen evaluiert und gegebenenfalls wieder an Visual C++ angepasst. 
Dies umfasste sowohl kleinere Syntaxänderungen als auch Änderungen an 
Objektstrukturen (einige Abstürze unter Windows konnte ich auf Probleme 
mit der RTTI\footnote{Runtime Type Information} zurückführen).

Ich habe einen ersten Prototyp des Scheduling Dialog erstellt, den dann
Tammo aus damaligen zeitlichen Engpässen weiterentwickelt hat.

Weiterhin zeichnete ich mich für die Druckfunktionalität sowohl für die 
Netzwerke als auch für die Scheduling Übersicht verantwortlich.

Außerdem oblag es mir das manuelle Routen von Verbindungen zu implementieren.
Nach einigen mehr oder weniger komplizierten Versuchen habe ich dafür eine
im Detail trickreich zu entwickelnde aber erstaunlich einfach zu bedienende 
Möglichkeit gefunden, die sich nahtlos in das vorhandene Konzept eingegliedert
hat.

Dafüber hinaus habe ich meine langjährige Erfahrung in der Entwicklung und 
nicht zuletzt auch Fehlerbereinigung von Software eingebracht um im 
gesamten Projekt kleinere beobachtete Bugs aufzuspüren und gleich zu 
beseitigen (``I've got a debugger and I'm not afraid to use it!'').

Last and probably least war ich partiell an der Einführung von CPPUnit,
der Erstellung des Handbuchs sowie des Abschlussberichts beteiligt.

\subsection{Team}
Das Team hat sich erfreulicherweise als überaus kompetent erwiesen, eine
Eigenschaft die leider auch in höheren Semestern der Softwaretechnik nicht
immer selbstverständlich ist. Auch Zwischenmenschlich sind mir keinerlei
Probleme aufgefallen, im Gegenteil. Die Team-Grüße war der Aufgabenstellung
angemessen.

Das Team war größtenteils sehr motiviert und auch das Projekt Management hat 
sehr gut funktioniert. Alles in allem eine sehr willkommene Abwechslung zu 
meinem in fast all diesen Punkten etwas gescheitertem StuPro A.

\subsection{Fazit}
Meine Erachtens war das Projekt ein voller Erfolg, die Vorgaben wurden laut
des Kunden zur vollsten Zufriedenheit erfüllt. Das Arbeitsklima war durchweg
angenehm und der verwendete Software-Prozess war den leicht ungenauen, 
aufgrund der weitergehenden Forschung teilweise auch dem Kunden noch nicht 
hundertprozentig bekannten Anforderungen gewachsen.

\section{Steffen Pingel}

\subsection{Aufgaben}

Ich habe vielfältige Aufgaben während des POA Projekts übernommen. In
erster Linie war ich als Projektleiter für das Management des Projekts
und dessen erfolgreichen Abschluss verantwortlich. Ich habe mich
bemüht, im Sinne des Management-By-Objectives, Ziele zu setzen, das
Team zu koordinieren und nur zu führen, wenn es Notwendig war.

Das Team war aus sehr unterschiedlichen Mitgliedern zusammen
gesetzt. Mir waren zu Projektbeginn nur zwei Mitglieder persönlich
bekannt. Die Fähigkeiten, Stärken und sehr unterschiedlichen
Arbeitsweisen der anderen lernte ich erst während des Projekts
kennen. Erschwerend kam hinzu, dass der Erfahrungshorizont innerhalb
des Teams sehr unterschiedlich ausgeprägt war. Vier von den sieben
Mitgliedern hatte zu Beginn des POA Projekts noch kein, wie im
Studienplan eigentlich ausdrücklich gefordert, Studienprojekt
begonnen.

Desweiteren erwiess sich die Koordination der individuellen
Wochenpläne als Schwierig. Bedingt durch unterschiedlich gewählte
Vorlesungen, andere Studienprojekte, Urlaubsplanung, Krankheit und
Nebenbeschäftigungen war es kaum Möglich einen gemeinsamen Termin zu
finden, der für alle Teilnehmer passend war. Dennoch haben wir sowohl
während der Vorlesungsfreien Zeit als auch während der Vorlesungszeit
Kernarbeitszeiten eingeführt, die die Kommunikation stark erleichtert
haben. 

Im Laufe des Projekts habe ich neben der Organisation zahlreiche
produktive Tätigkeiten übernommen. Ich habe mich an der Verfassung des
Angebots beteiligt sowie den Entwurf mitgestaltet. Während der
einzelnen Iterationen habe ich bemüht meinen Anteil an der Kodierung
möglichst weit einzuschränken. Zum einen stand eine ausreichende Anzahl
von guten Entwicklern im Team zur Verfügung und zum anderen war der
organisatorische Anteil, den ich zum größten Teil erledigt habe, höher
als erwartet. 

Maßgeblich habe ich mich um die Umsetzung des Tests bemüht. Das
Interesse der Entwickler an Tests war erwatungsgemäß nicht besonders
hoch. Angesichts des hohen Anteils an schwierig automatisiert
testbaren GUI Quellcodes verständlich. Der Test bestand aus einer
Suite von automatisierten Regression-Tests, die vorwiegend von mir
erstellt wurden. Die Qualität der Tests wurde anhand der
Anweisungsüberdeckung mit dem Werkzeug gcov gemessen.

Die Ausgabe von gcov wurde mit gcover grafisch als HTML Seiten
aufbereitet. Gcover ist als Teilprojekt von POA entstanden und
orientiert sich an anderen Werkzeugen zur Messung der Testüberdeckung,
von denen allerdings kein kostenloses zur Auswertung der gcov Asugabe
zur Verfügung stand. 

\subsection{Fazit}

Besonderen Wert habe ich auf die Anwendung, der im
Softwaretechnik-Studium erworbenen Kenntnisse gelegt. Auch auf Grund
von Erfahrungen aus vorherigen einem Studienprojekt war es mir wichtig
den Focus nicht ausschließlich auf den Umfang des Produkts zu legen,
sondern vor allem auch die Qualität und das Vorgehensmodell zu
beachten.

Abschliessend beurteile ich das Projekt als Erfolg. Alle Team
Mitglieder haben sich bemüht das im Studium erworbene Wissen praktisch
umzusetzen. Im Verlaufe des Projekts hat sich eine produktive
Teamdynamik entwickelt. Das gewählte Vorgehensmodell erscheint mir den
besonderen Anforderungen eines Studienprojekts gerecht zu werden. Das
entstandene Produkt erfüllt die Anforderungen des Kunden und ist
qualitativ zufriedenstellend.

\section{Tammo van Lessen}

\appendix

\chapter{Erklärung gemäß Prüfungsordnung}

Ich erkläre hiermit, daß ich im Rahmen meiner Mitarbeit am
Studienprojekt B - Programmierumgebung Offener Antrieb außer von den
Betreuern vorgesehenen bzw. genehmigten Hilfsmitteln keine unzuläßige
Hilfe in Anspruch genommen habe.
\vspace{5cm}
Stuttgart, den xx. Mai 2004
\vspace{5cm}

\end{document}
