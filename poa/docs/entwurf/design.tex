%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Entwurf
%% $Id: design.tex,v 1.19 2004/06/16 12:54:57 vanto Exp $
%% Achtung: Diese Datei wird in den Entwurf inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% classname
\newcommand\cn[1]{{\bf \texttt{#1}}}
% method
\newcommand\m[1]{\texttt{#1}}

\chapter{Architektur}

\section{Übersicht}

Die Architektur von POA gliedert sich in stark zusammenhängende
Module, die durch schmale Schnittstellen miteinander kommunizieren und
so eine geringe Kopplung aufweisen. So kann jedes dieser Module
einzeln an geänderte Anforderungen angepasst werden, wobei die
Interoperabilität erhalten bleibt.

Auf diese Weise wird die größtmögliche Flexibilität für die
Weiterentwicklung und Wartung der Software sichergestellt. Aufgrund
des forschungsnahen Charakters des POA-Projekts wurde auf die
Flexibilität der Architektur besonderer Wert gelegt.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{../abschlussbericht/design}
  \caption{POA Architektur}\label{arch_grafik}
\end{figure}

In Abbildung \ref{arch_grafik} werden die Module von POA
dargestellt. Im Folgenden wird eine kurze Beschreibung gegeben,
Details folgen im Kapitel \ref{modules}.

Die grün dargestellten Module bilden die Basis des
POA-Systems. Entwürfe für Regler auf dem Offenen Antrieb werden in
Projekten (\ref{model}) entwickelt. Die Daten eines Projekts werden
in den Models des Projekts gespeichert.

Die rot dargestellten Module, Problemmanager (\ref{problem_manager}),
Scheduling (\ref{scheduling}) und Download (\ref{download}), bilden die
wesentlichen Aufgaben von POA ab.

\begin{itemize}
\item Prüfen der Integrität eines Projekts und Anzeige der
  aufgefundenen Probleme
\item Automatische Berechnung eines optimalen Schedulings für das
  Netzwerk von Blöcken
\item Compilation des Sourcecodes und Download auf die spezifizierten
  CPUs
\end{itemize}

Die in blau eingefärbten Module realisieren die
Benutzungsschnittstelle von POA. Das Modul GUI umfasst Klassen zur
Darstellung von Dialogen. Die Views (\ref{view}) visualisieren die
relevanten Nutzdaten und das Routing-Modul (\ref{routing}) wird eingesetzt, um
Konnektoren überkreuzungsarm in ein Netzwerk einzubringen.

Schließlich bietet das Utils Modul diverse Funktionalität, die häuftig
benötigt wird. Die Klassen dieses Moduls sind Kandidaten um in
folgenden Projekten wiederverwendet zu werden.

\subsection{Projekte in POA}

Um mehrere Konfigurationen des Offenen Antriebs bearbeiten zu können,
stellt POA das Projekt-Konzept zur Verfügung. Die Arbeit an einer
bestimmten Konfiguration (alle Blöcke, Konnektoren, Source Code,
Layout der Darstellungen) wird in ein Projekt
zusammengefasst. Projekte können als ganzes auf ständigen Speicher
gespeichert und von diesem geladen werden.

Aufgrund ihrer zentralen Stellung bietet die Sicht auf ein Projekt
ebenfalls einen guten Ausgangspunkt für die Betrachtung der
Architektur. (siehe auch \ref{project})

\subsection{Speicherung von Projekten}

Projekte werden in einem Projekt-Ordner auf der Festplatte
gespeichert. Der Name des Ordners ist gleichzeitig der Name des
Projekts. Der Projekt-Ordner enthält die Datei project.xml, die alle
Projekt-Daten enthält.

Zusätzlich gibt es für jede CPU des Projekts einen Unter-Ordner, der
die wiederum die Ordner inc für zu inkludierende
C-Präprozessor-Definitionen oder C-Deklarationen, lib für Bibliotheken
gegen die der selbstgeschriebene Code zu linken ist, und src für den
Quelltext für die CPU enthält. Für diesen Quelltext kann POA
Rahmencode generieren.

\section{Module}
\label{modules}

Die Architektur von POA lässt sich in stark zusammenhängende
Module aufteilen, die eine gerine Kopplung aufweisen. In den folgenden
Abschnitten sind diese Module im Detail beschrieben.

Die Zuordnung von einzelnen Klassen zu Modulen lässt sich in der Regel
aus dem Klassennamen ableiten oder ist aus dem
Software-Architektur-Poster anhand der Schattierung ersichtlich.

\subsection{Datenmodell (Model)}
\label{model}

In den Model-Klassen wird das Datenmodell eines Projekts
repräsentiert. In POA werden Daten in Objekten der Klassen
\cn{BlockModel} und \cn{PinModel}, sowie abgeleiteter Klassen
gespeichert. Die Klasse \cn{Projekt} verwaltet die Model-Objekte. Sie
dient als Container und stellt Methoden zur Serialisierung und
Deserialisierung von Projekten in einem POA-spezifischen XML-Format
zur Verfügung. Wird ein Projekt verändert, d.h. ein Block hinzugefügt,
entfernt oder verändert, muss die Methode \m{setModified()}
aufgerufen werden.

\subsubsection{Serialisierung}

Der Mechanismus zum Erstellen des XML Dokuments bzw. des Datenmodells
aus einem XML Dokument ist in den Model-Klassen gekapselt. So ist es zum
Einen möglich, jedes Objekt unabhängig vom Projekt zu serialisieren,
zum Anderen vereinfacht es die Wartbarkeit. Bei Erweiterungen der
Model-Klasse um weitere Datenfelder müssen nur die \m{serialize()} und
\m{deserialize()} Methoden angepasst werden, der Code in der Klasse
\cn{Project} bleibt gleich. Wichtig ist hier, dass bei abgeleiteten
Klassen immer die serialize/deserialize-Methoden der Superklasse
aufgerufen werden, da sich der Mechanismus auf die gesamte
Klassenhierarchie verteilt.  

Für die Erzeugung von Objektinstanzen bei der Deserialisierung ist die
Klasse \cn{ModelFactory} zuständig. Sie erzeugt anhand der
XML-Attributs ''block-type'' in dem jeweiligen XML-Element das
entsprechende Model-Objekt. Über die Methoden \m{addBlock()} und
\m{removeBlock()} werden dem Projekt neue Modellblöcke bekannt
gemacht bzw. wieder entfernt.

\subsubsection{Blöcke}

Die Model-Klassen sind von der abstrakten Klasse \cn{AbstractModel}
abgeleitet. Die Felder der abstrakten Klasse enhalten die gemeinsamen
Metadaten aller Blöcke und werden in der Blockbibliothek angezeigt.
Die Methode \m{createView(GridCanvas*)} erzeugt für
eine Model-Object eine korrespondierendes View-Objekt. Eine Aufruf der
Methode \m{updatePerformed()} benachrichtigt das View-Object über
Änderungen im Zustand des Model-Objects und sollte aufgerufen werden,
wenn z.B. die Taktraten eines Blocks geändert wurde.

Die Klasse \cn{BlockModel} ist von \cn{AbstractModel} abgeleitet und
repräsentiert Blöcke mit Pins. Ausserdem werden in ihr Informationen
zum Laufzeitverhalten der Blöcke abgelegt. Über die Methoden
\m{addPin(PinModel*)} bzw. \m{deletePin(PinModel*)} wird dem Block ein
Pin hinzugefügt bzw. wieder entfernt. Wurde dem Block ein Pin
hinzugefügt, erfolgt eine Benachrichtigung an das 
korrespondierende View-Objekt über das Signal \m{pinAdded(PinModel*)}.
Wird ein \cn{BlockModel}-Objekt gelöscht wird das Signal
\m{deleted(BlockModel*)} gesendet, und das View-Objekt gelöscht.

Es gibt zwei Sonderfälle im Datenmodell: Die CPUs und die
Multiplexer-Blöcke. Diese werden durch die Klassen \cn{CpuModel} und
\cn{MuxModel} abgebildet und erben von \cn{Blockmodel}.

\subsubsection{Pins}
Die Klasse \cn{PinModel} repräsentiert die Pins eines Blocks. Ihre
Instanzen werden von den BlockModels verwaltet. Eine Verbindung
zwischen zwei Pins wird mittels \m{attach(PinModel *connectTo)}
hergstellt. Damit wird auch das BlockView benachrichtigt. Der Typ
(\m{type}) des Pins entscheidet, ob es sich bei dem Pin um einen
Eingangs-, Ausgangs- oder einen episodischen Pin handelt.
Über den Konstruktor muss dem Pin der Vaterblock mitgeteilt werden.

Die Signale \m{deleted(), detached()} und \m{updated()} benachtigten
interessierte Klassen, wenn ein Pin entfernt werden soll, wenn eine
Verbindung gelöst wurde oder wenn Eigenschaften des Pins verändert
wurden. 

\subsubsection{Drag and Drop, Zwischenablage}

Zum visuellen erzeugen von Blöcken wird bei POA die Drag\&Drop-Idee
verwendet. Dazu zieht der Benutzer ein Objekt aus der Blockbibliothek
in den Arbeitsbereich (\cn{GridCanvas}). Unter der
Haube werden die Objekte beim Herausziehen aus der Bibliothek über die
Serialisierungsmethoden in einen XML-String umgewandelt und beim
''fallen lassen'' über die \cn{ModelFactory} instanziert, von
Bibliotheksinformationen bereinigt und in das Projekt eingefügt. Das
dazugehörige View-Objekt wird an den aktuellen Maus-Koordinaten
erstellt.  Das Einfügen in die Bibliothek funktioniert analog dazu.
Die Zwischenablagefuntionen sind genauso implementiert. Beim Kopieren
eines Objekts werden die Daten serialisiert und in die Zwischenablage
kopiert und beim Einfügen wieder deserialisiert. Da z.B. bei CPUs der
Sourcecode mitkopiert werden soll, ist für die
Copy\&Paste-Funktionalität eine erweiterte Serialisierung notwendig.
Daher sieht die abstrakte Superklasse für die Serialisierung für die
Zwischenablage eine eigene Methode vor: \m{serializeCopy()}.

\subsection{View}
\label{view}

Views werden verwendet, um dem Benutzer die Daten zu präsentieren. Sie
werden über Signals benachrichtigt, wenn sich ein Model verändert und
passen dann die grafische Darstellung entsprechend an.

Der \cn{GridCanvas} ist eine Arbeitsoberfläche für ein POA-Netzwerk. Die
Basisklasse für den \cn{GridCanvas} sowie für alle Views darauf werden von
der QT-Bibliothek gestellt. Für POA musste nur eine Spezialisierung
dieser Basisfunktionalität durchgeführt werden.

Die \cn{GridCanvas}-Objecte werden in der \cn{Project}-Klasse
verwaltet. Zu jedem Projekt kann es mehrere \cn{GridCanvas}-Instanzen
geben. Diese Funktionalität wird bisher allerdings nicht genutzt, es
wird immer nur ein \cn{GridCanvas} pro Projekt angezeigt.

Ohne selbst als Model gelten zu können, stellt der \cn{GridCanvas} nur eine
virtuelle Arbeitsoberfläche dar. Für die Darstellung eines Teils des
\cn{GridCanvas} sind \cn{CanvasView}-Objekte zuständig. So kann dieselbe
Arbeitsoberfläche in mehreren Fenstern geöffnet werden und in jedem
Fenster kann ein anderer Ausschnitt der Arbeitsoberfläche angezeit
werden.

Die meisten Views, die speziell für POA entwickelt wurden, repräsentieren
grafische Objekte auf einem \cn{GridCanvas}. Dazu gehören \cn{BlockView},
\cn{PinView} und \cn{TextView}.

Eine besondere Behandlung ist allerdings für Konnektoren notwendig.
Konnektoren können auf dem Canvas nicht ohne weiteres dargestellt
werden, weil Qt seine Funktionalität hier auf wenige geometrische
Objekte beschränkt. Die Linienzüge die In POA verwendet werden,
bestehen deshalb aus mehreren \cn{ConnectorViewSegment}-Objekten. Um
von der Verwaltung der einzelnen Segmente zu abstrahieren wurde die
Klasse \cn{ConnectorViewList} eingeführt. Objekte dieser Klasse
agieren als View für ein Verbindung zwischen zwei
\cn{PinModel}-Objekten, aber delegieren die tatsächliche
Darstellungsaufgabe an mehrere \cn{ConnectorViewSegment}-Objekte.

\subsection{Controller}
\label{controller}

Als Controller wird die Komponente bezeichnet, die Benutzereingaben
und interne Ereignisse verarbeitet und die Synchronisation zwischen
View und Model sicherstellt.

Aktionen, die der Benutzer durch Eingaben anstößt, lösen in QT Signals
aus. Diese Signals werden in POA lokal in dem entsprechenden
View-Objekt verarbeitet, z.B. in \cn{CanvasView} für alle Aktionen,
die auf dem Canvas geschehen (z.B. Selektieren eines Blocks) oder in
MainWindow (z.B. bei Aktivieren eines Menüpunkts). Aufwändige
Bearbeitungen werden in spezielle von der Klasse \cn{CanvasViewAction}
abgeleitete Objekte ausgelagert.

Eine besondere Auslagerung der Controller bietet sich für POA nicht
an. Die Benutzer-Eingaben erfolgen auf einer bestimmten View und das
zugehörige View-Objekt hat die nötigen Kompetenzen, um die Eingabe zu
verarbeiten. Falls eine Bearbeitung mehrere Schritte erfordert, so
erzeugt das View-Objekt ein Action-Objekt, um die Aufgabe zu
erledigen.

\subsection{Scheduling}
\label{scheduling}

Optimales Scheduling bedeutet in POA die Berechnung eines optimalen
Offsets für jeden Block, da die Taktraten für jeden Block bereits
feststehen.

Die optimalen Offsets werden in POA für bestimmte Signalpfade
berechnet. Hierzu dient dienen Objekte der Klasse Path. Für jeden
gewünschten Signallaufpfad wird ein solches Objekt erzeugt. Dann kann
die Signallaufzeit minimiert werden, indem alle Path-Objekte in einer
definierten Reihenfolge einzeln optimiert werden.

Die Path-Objekte verwenden dazu eine Graph-Struktur, die von der
Klasse \cn{BlockGraph} angeboten wird. Ein \cn{BlockGraph} besteht aus
einer Reihe von \cn{BlockNode}-Objekten. In den
\cn{BlockNode}-Objekten kann ein Flag gesetzt werden. Anhand dieses
Flags erkennt der Optimierungsalgorithmus, ob ein bestimmter Knoten
bereits einen optimalen Offset erhalten hat, oder noch verändert
werden darf.

Eine Auswahl von Signallaufpfaden, kann der Benutzer in dem
AutoSchedulingDialog vornehmen. Dieser Dialog bedient sich des
BlockGraphs, um eine Liste aller Blöcke anzuzeigen, die noch in keinem
Pfad enthalten sind.

\subsection{Download}
\label{download}

Der Download ist in der Klasse \cn{DownloadManager} implementiert. Zur
Übertragung der Daten wird die QExtSerialPort-Bibliothek verwendet.
Die Bibliothek einheitliche Methoden zum Zugriff auf die serielle
Schnittstelle für Windows und Linux. Die Initialisierung erfolgt in
der \m{initializeAndOpen()} Methode. Hier können die fest
programmierten Übertragungsparameter und die Geschwindigkeit geändert
werden. Die Übertragung der Daten erfolgt in der \m{download()}
Methode und kann hier angepasst werden, falls sich das
Übertragungsprotokoll ändert. In der aktuellen Implementierung kann
der kompilierte Quellcode einer einzelnen CPU übertragen werden.
 
\subsection{Routing}
\label{routing}

Die Routing Schnittstelle ist sehr abstrakt definiert. Es wird
lediglich die Verbindung zweier Punkte auf einem GridCanvas gefordert.
Zwei Routing Algorithmen mit sehr unterschiedlichen Eigenschaften
implementieren diese Schnittstelle.

Der \cn{DirectRouter} stellt die Verbindung anhand von Fallunterscheidungen
mit der geringsten Anzahl von Knickpunkten her ohne Überschneidungen
zu berücksichtigen. Der Algorithmus ist ausreichend schnell, um die
Verbindungen während des Verschiebens von Blöcken simultan
neuzuberechnen. 

Der \cn{DijkstraRouter} benutzt den Dijkstra Algorithmus um eine optimale
Route mit möglichst wenig Knickpunkten und Überschneidungen zu finden.
Auf Grund der Vielzahl der möglichen Wege beträgt die Laufzeit des
Algorithmus in der Regel ein vielfaches des DirectRouter.

Durch Ableitung der \cn{ConnectorRouter} Klasse und Erweiterung der
\cn{GridCanvas} Klasse ist eine Implementierung von zusätzlichen
Routing-Algorithmen möglich.

\subsection{Problemmanager}
\label{problem_manager}

Die Klasse \cn{ProblemReportManager} validiert ein Projekt und stellt
eine Baumansicht mit den Ergebnissen zur Verfügung. Im ersten Schritt
werden alle Blöcke sequentiell geprüft. Im zweiten Schritt werden die
Verbindungen zwischen den Blöcken geprüft. Die Validierung erfolgt in
der \m{report()}-Methode und \m{checkBlock()}-Methode. Hier können
weitere Prüfungen eingefügt werden. Für jeden Fehler wird ein Objekt
vom Typ \cn{ProblemReportItem} erzeugt, das in dem Ergebnissbaum
angezeigt wird.

\subsection{Querschnittsmodule}

Einige Klassen können keinem Modul zugeordnet werden, da diese von
vielen Modulen benutzt werden. Einige dieser Querschnittsklassen sind
im folgenden beschrieben.

\subsubsection{Einstellungen (Settings)}

In der \cn{Setting}-Klasse werden globale Einstellungen wie Farben, Schriftarten
und Pfade verwaltet, die zum Teil auch über den Einstellungsdialog vom
Benutzer geändert werden können. Änderungen von Einstellungen, die
direkt in der Anwendung sichtbar gemacht werden sollen, werden über
entsprechende Signale bekannt gemacht.


%%% Local Variables: 
%%% TeX-master: "entwurf"
%%% End: 
%%% vim:tw=79:
