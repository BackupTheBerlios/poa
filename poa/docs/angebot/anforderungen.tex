%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Anforderungen
%% $Id: anforderungen.tex,v 1.12 2003/06/29 21:22:53 squig Exp $
%% Achtung: Diese Datei wird ins Angebot inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Anforderungen
\chapter{Anforderungen}
Dieses Kapitel beschreibt die Anforderungen des Auftraggeber an das
Studienprojekt B, ''Programmierumgebung Offener Antrieb'' (POA).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hintergrund
\section{Hintergrund}
Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen gemacht.
Viele dieser Entwicklungen beinhalten neue Kinematiken, wie z.B. die
Parallelkinematiken und Sensoren (z.B. den Ferraris 
Relativbeschleunigungssensor).\par
Dadurch entstehen neue Anforderungen an die Antriebsregelung. Zusätzliche
Sensor-Signale müssen in den Reglerstrukturen berücksichtigt werden -- oder
es werden sogar völlig neue Reglerstrukturen benötigt.\par
Die momentan auf dem Markt erhältlichen Reglersysteme erlauben meist
weder die Berücksichtigung neuartiger Sensoren, noch bieten sie die
Möglichkeit, eigene anwenderspezifische Reglerstrukturen zu implementieren.\par
Daher wird am ISW eine Plattform für die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene Funktionalitäten
zu integrieren. Diese Plattform wird am ISW kurz als ``Offener Antrieb''
bezeichnet.  \par
Die hardwaretechnische Realisierung erfolgt in Form einer PC-Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX'' Baustein. Es
handelt sich dabei um ein CPLD\footnote{Complex Programmable Logic Device},
das sich frei programmieren lässt. Der Anwender hat die Möglichkeit, die
Funktion des Bausteins seinen Bedürfnissen anzupassen.\par
Um die Offenheit für jeden Anwender nutzbar zu machen, wird für das CPLD eine
Architektur festgelegt, die es ermöglicht, einzelne Funktionalitäten in Form
von Modulen zu implementieren. Diese Module können aus festprogrammierten
Schaltungen (Cores) und freiprogrammierbaren CPUs bestehen. Jedes Modul kann
auf die Signale aller anderen Module zugreifen und stellt seine eigenen
Ausgangssignale allen anderen Modulen zur Verfügung.\par
Inhalt dieses Angebotes ist es, eine Programmierumgebung für das Netzwerk
von CPUs und Cores zu schaffen, in dem ein bereits auf dem CPLD vorhandenes
Netzwerk konfiguriert werden kann.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionale Anforderungen
\section{Funktionale Anforderungen}

Die ``Programmierumgebung Offener Antrieb'' soll eine 
grafische Oberfläche mit folgenden wesentlichen Funktionalitäten bieten:
\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Editierung einer CPLD-Modulbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung für eingebette CPU-Module in einem CPLD-Layout
\item Plausibilitätsprüfung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen von Quellcode für die CPU-Module
\item Speichern und Öffnen von CPLD-Layouts und zugehörigem Quellcode
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}
Auf die Einzelheiten der wesentlichen Funktionalitäten und der Abgrenzung der
aufgeworfenen Begriffe wird in den folgenden Abschnitten eingegangen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD Layouts
\subsection{CPLD Layouts}
Ein CPLD Layout ist ein virtuelles Abbild der realen Konfiguration
(Vernetzung der CPLD-Funktionsblöcke) eines CPLD Hardware-Bausteins.
Dabei besteht die virtuelle Abbildung aus Funktionsblöcken (CPUs, Cores,
E/A-Blöcke) und Signalleitungen.\par
Im zu entwickelnden System soll ein CPLD Layout rasterisiert dargestellt
werden und durch Maus- und Tastatureingaben manipulierbar sein. Dabei
werden Funktionsblöcke mit der Maus in ein Raster eingebettet und durch
einzelne Linien, die die Signalleitungen symbolisieren, verbunden.
Die Funktionsblöcke selbst sollen konfigurierbar und editierbar sein.\par
CPLD-Layouts sollen XML-basiert speicher- und ladbar sein. Sie werden
zusammen mit dem zugehörigen Source- und evtl. vorhandenen Object-Code
in einer geeigneten Verzeichnisstruktur abgelegt.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD-Modulbibliothek
\subsection{CPLD-Modulbibliothek}
Die Modulbibliothek ist eine CPLD-Layout übergreifende Sammlung von
Funktionsblöcken (CPU, Cores, E/A-Blöcke), die in CPLD-Layouts
einbettbar sein sollen. Die Funktionsblöcke sollen in einer
XML-Struktur verwaltet werden. Die Modulbibliothek soll bei jedem
Systemaufruf automatisch geladen werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionsblock
\subsection{Funktionsblock}
Ein Funktionsblock ist ein virtuelles Abbild eines CPU-, Core- oder
E/A-Bausteins auf einem CPLD. Dabei sollen an allen Funktionsblöcken
die Ein- und Ausgänge mit Signalleitungen verbunden werden können.
\par
Speziell bei CPU-Blöcken soll überdies die Anzahl der Ein- und
Ausgänge, die Benennung der E/As, das Einstellen eines Zeitoffsets,
das Setzen einer logischen Taktrate konfigurierbar sein und der auf
dem jeweiligen CPU-Block auszuführende Sourcecode editierbar sein.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Rahmencodegenerierung
\subsection{Rahmencodegenerierung}
Zur Editierung von C-Quellcode für CPU-Blöcke soll ein vom Auftraggeber
vordefiniertes C-Template kontextabhängig für die existierende
Konfiguration eines CPU-Blocks verwendet werden, um Rahmencode zu generieren.
Dabei soll die Benennung der Signal-Ein- und Signal-Ausgänge im C-Sourcecode
eines einzelnen CPU-Blocks angepaßt werden. Hierzu soll ein
Textersetzungsalgorithmus auf der Basis von Templates verwendet werden.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plausibilitätsprüfung
\subsection{Plausibilitätsprüfung}
Die Vernetzung von Funktionsblöcken in einem entworfenen CPLD-Layout soll
auf ihre Plausibilität geprüft werden können, im Einzelnen:
\begin{itemize}
\item Prüfung auf unverknüpfte E/As
\item Prüfung auf falsch verknüpfte E/As (E-E, etc.)
\end{itemize}
Sofern das entworfene CPLD-Layout Ungereimtheiten aufweist, soll eine
Warnmeldung ausgegeben werden, die die fehlerhaften Verknüpfungen aufführt.\par


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Optimierung
\subsection{Optimierung}
Der Entwurf eines plausiblen CPLD-Layouts soll durch einen gekoppelten
Signallaufzeitsermittlungs- und -optimierungs-Algorithmus optimiert werden
können. Hierzu wird zur Laufzeitermittlung ein Laufzeitermittlungsprogramm
für CPLD-CPU-Block Object-Code verwendet, das vom Auftraggeber zu liefern
ist. Sollte diese Software keine hinreichend genaue Laufzeitermittlung
ermöglichen werden alternative Möglichkeiten geprüft. Sollte das zu
keinem Ergebniss führen, kann die Optimierung nur auf Grund von
manuell eingegebenen Laufzeiten erfolgen mit entsprechenden
Abweichungen bei den Ergebnissen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Compilieren und Herunterladen
\subsection{Compilieren und Herunterladen}
Der Quellcode der CPU-Blöcke sollen durch einen externen Compiler
compiliert werden können, der vom Auftraggeber zu liefern ist.
\par
Weiterhin soll der Quellcode auf das CPLD heruntergeladen werden
können. Um diese Anforderung umsetzen zu können, hat der Kunde die
Schnittstelle sowie ein Beispielprogramm zu liefern.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Externe Programme
\subsection{Externe Programme}
Zur Editierung von Sourcecode, zum Compilieren von Sourcecode, zum
Herunterladen von Object-Code und zur Laufzeitbestimmung sollen externe
Programme eingesetzt werden.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Konfiguration
\subsection{Konfiguration}
Es soll der externe Editor, der externe Compiler, der Pfad zum C-Source
Template und das externe Download-Tool konfigurierbar sein.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionale Anforderungen
\section{Nicht funktionale Anforderungen}
Die Implementierung der Software erfolgt in C++ auf der Basis von
Trolltech Qt 3.1.1. Als Zielplatform wird Redhat GNU/Linux 8.2
festgelegt.

\subsection{Hardware}
Die minimalen Hardware Anforderungen entsprechen denen der
Zielplattform bzw. der verwendeten Bibliotheken.

\subsection{Mengengerüst}
\begin{itemize}
\item Eine CPLD besteht aus maximal 30 Funktionsblöcken.
\item Ein Funktionsblock hat maximal 50 Ein- bzw.\ Ausgänge, die mit
  Bussen oder Signalleitungen verbunden werden können.
\item Die Modulbibliothek enthält maximal 20 Funktionsblöcke.
\end{itemize}

\subsection{Wartbarkeit}
Die Wartbarkeit des Quellcodes wird durch eine verbindliche
Codierrichtline und Kommentierung sichergestellt.

%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
