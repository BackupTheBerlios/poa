%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Entwurf
%% $Id: design.tex,v 1.6 2004/06/04 21:19:21 squig Exp $
%% Achtung: Diese Datei wird in den Entwurf inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Architektur}

\section{Übersicht}

\section{Entwurfsmuster}

Während des Entwurfs von POA konnte ein Teil der Implementierung mit
Hilfe von Entwufsmustern der Softwaretechnik realisiert
werden. Entwufsmuster beschreiben eine Lösungsstrategie für ein
abstraktes Problem.

\subsection{Model-View-Controller}

Die Speicherung der Daten ist vollständig von der Visualisierung
unabhängig. Die Daten werden in sogenannten Model Klassen verwaltet
und von View Klassen angezeigt, wobei eine 1:n Beziehung besteht. Die
Kommunikation zwischen den Klassen erfolgt anonym über
Benachrichtigungen (siehe auch \ref{Benachrichtigungen}). 

Eine Model Klasse stellt über get-Methoden oder Iteratoren den Zustand
zur Verfügung. Dieser Zustand wird von einer View-Klasse dem
Anwendungszweck entsprechend angezeigt. Konkret werden die Blöcke,
Pins und Verbindungen in POA jeweils durch Datenobjekte
repräsentiert. Diese werden mit Hilfe von entsprechenden Viewobjekten von der
GridCanvas Klasse angezeigt. 

\subsection{Benachrichtigung}

Die QT Bibliothek erweitert den Sprachumfang von C++ über einen
speziellen Kompiler, den Meta-Object-Compiler (MOC), mit einem
Benachrichtigungskonzept. Mit Hilfe von
Benachrichtigungen können Objekte anderen Objekten Mitteilungen über
Zustandsänderungen schicken. Die nahtlose Integration in die
Programmiersprache ermöglicht eine besonders einfache Verwendung des
Mechanismus.

Die Benachrichtigungen (Signals) werden durch das Schlüsselwort emit
gesendet und von speziellen Methoden (Slots) empfangen. Die Signals
und Slots werden in den Klassendeklarationen angegeben. Die Verbindung
zwischen zwei Objekten wird mittels der connect Methode hergestellt. 

In POA wird an meheren Stellen gebrauch von dem Signal-Slot
Mechanismus gemacht.

\subsection{Strategie}

Das Strategiemuster ermöglicht den Algorithmus für eine Problemlösung
austauschbar zu machen. 

In POA wurde die Routing Schnittstelle für die Verbindungen zwischen
den Blöcken abstrakt definiert und konkret mit zwei verschiedenen
Algorithmen implementiert. Die Algorithmen haben unterschiedliche
Eigenschaften in Bezug auf die Laufzeit und Qualität des Ergebnisses. 

\subsection{Singleton}

Das Singleton Muster wird verwendet, wenn ein Objekt nur genau einmal
instanziert werden soll. Dadurch lassen sich auch in
objekt-orientierten Systemen, äquivalent zu globalen Variablen in
imperativen Systemen, global verfügbare Objekte realisieren,
die über eine definierte Schnittstelle angesprochen werden können. 

In POA ist lediglich die Settings Klasse als Singleton implementiert.

\section{Module}

Die Architektur von POA lässt sich in stark zusammenhängende
Module aufteilen, die eine gerine Kopplung aufweisen. In den folgenden
Abschnitten sind diese Module im Detail beschrieben.

Die Zuordnung von einzelnen Klassen zu Modulen lässt sich in der Regel
aus dem Klassennamen ableiten oder ist aus dem POA
Software-Architektur anhand der Schattierung ersichtlich.

\subsection{Datenmodell (Model)}

In den Model-Klassen 

\subsection{View}

\subsection{Scheduling}

Das Scheduling Modul 

\subsection{Download}

Der Download ist in der Klasse DownloadManager implementiert. Zur
Übertragung der Daten wird die QExtSerialPort Bibliothek verwendet.
Die Bibliothek einheitliche Methoden zum Zugriff auf die serielle
Schnittstelle für Windows und Linux. Die Initialisierung erfolgt in
der initializeAndOpen() Methode. Hier können die fest programmierten
Übertragungsparameter und die Geschwindigkeit geändert werden. Die
Übertragung der Daten erfolgt in der download() Methode und kann hier
angepasst werden, falls sich das Übertragungsprotokoll ändert.
 
\subsection{Routing}

Die Routing Schnittstelle ist sehr abstrakt definiert. Es wird
lediglich die Verbindung zweier Punkte auf einem GridCanvas gefordert.
Zwei Routing Algorithmen mit sehr unterschiedlichen Eigenschaften
implementieren diese Schnittstelle.

Der DirectRouter stellt die Verbindung anhand von Fallunterscheidungen
mit der geringsten Anzahl von Knickpunkten her ohne Überschneidungen
zu berücksichtigen. Der Algorithmus ist ausreichend schnell, um die
Verbindungen während des Verschiebens von Blöcken simultan
neuzuberechnen. 

Der Dijkstrarouter benutzt den Dijkstra Algorithmuss um eine optimale
Route mit möglichst wenig Knickpunkten und Überschneidungen zu finden.
Auf Grund der Vielzahl der möglichen Wege beträgt die Laufzeit des
Algorithmus in der Regel ein vielfaches des DirectRouter.

Durch Ableitung der ConnectorRouter Klasse und Erweiterung der
GridCanvas Klasse ist jederzeit eine Implementierung von zusätzlichen
Routing Algorithmen möglich. 

\subsection{Problemreport}

Die Klasse ProblemReportManager validiert ein Projekt und stellt eine
Baumansicht mit den Ergebnissen zur Verfügung. Im ersten Schritt
werden alle Blöcke sequentiell geprüft. Im zweiten Schritt werden die
Verbindungen zwischen den Blöcken geprüft. Die Validierung erfolgt in
der report() Methode und checkBlock() Methode. Hier können weitere
Prüfungen eingefügt werden. Für jeden Fehler wird ein Objekt vom Typ
ProblemReportItem erzeugt.

\subsection{Querschnittsmodule}

Einige Klassen können keinem Modul zugeordnet werden, da diese von
vielen Modulen benutzt werden. Einige dieser Querschnittsklassen sind
im folgenden beschrieben.

\subsubsection{Einstellungen (Settings)}

In den Settings werden globale Einstellungen wie Farben, Schriftarten
und Pfade verwaltet, die zum Teil auch über den Einstellungsdialog vom
Benutzer geändert werden können. Änderungen von Einstellungen, die
direkt in der Anwendung sichtbar gemacht werden sollen, werden über
entsprechende Signale bekannt gemacht.

\section{Persistenz}

\subsection{XML Format}




%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
