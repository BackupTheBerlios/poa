%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Abschlussbericht
%% $Id: abschlussbericht.tex,v 1.12 2004/06/06 00:57:19 squig Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,titlepage,12pt,ngerman]{scrbook}
\usepackage{../common/header}
\RequirePackage{hhline}

\RCSdef $Revision: 1.12 $
\RCSdef $Date: 2004/06/06 00:57:19 $

\newcommand\version{Version 1.0 \xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Deckblatt

\begin{titlepage}
\input{../common/logo}
\Huge Abschlussbericht

\setcounter{footnote}{0}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Versionsgeschichte

\section*{Versionsgeschichte}

\begin{itemize}

\item Version 1.0 (17.06.2004)

  Diese Version wurde dem Auftraggeber vorgelegt.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}

\section{Zweck des Dokuments}

Dieses Dokument beschreibt das Projekt ``Programmierumbgebung Offener
Antrieb'' (POA), das von Anfang Mai 2003 bis Ende April 2004 an der
Universität Stuttgart am Institut für Steuerungstechnik der
Werkzeugmaschinen und Fertigungseinrichtungen durchgeführt wurde. Das
Projekt wurde von sieben Softwaretechnik Studenten Necati Aydin,
Anselm Garbe, Stefan Hauser, Steffen Keul, Marcel Kilgus, Steffen
Pingel und Tammo van Lessen im Rahmen eines Studienprojekts B
ausgeführt. Im Folgenden wird ein Überblick über die erzielten
Ergebnisse, den Projektverlauf und die persönlichen Eindrücke der
Teilnehmer gegeben.
 
\section{Projekthintergrund}

Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen
gemacht.  Viele dieser Entwicklungen beinhalten neue Kinematiken, wie
z.B. die Parallelkinematiken und Sensoren (z.B. den Ferraris
Relativbeschleunigungssensor).  Dadurch entstehen neue Anforderungen
an die Antriebsregelung. Zus"atzliche Sensor-Signale m"ussen in den
Reglerstrukturen ber"ucksichtigt werden -- oder es werden sogar
v"ollig neue Reglerstrukturen ben"otigt.

Die momentan auf dem Markt erh"altlichen Reglersysteme erlauben meist
weder die Ber"ucksichtigung neuartiger Sensoren, noch bieten sie die
M"oglichkeit, eigene anwenderspezifische Reglerstrukturen zu
implementieren.

Daher wird am ISW eine Plattform f"ur die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene
Funktionalit"aten zu integrieren. Diese Plattform wird am
ISW\footnote{Institut f"ur Steuerungstechnik der Werkzeugmaschinen und
  Fertigungseinrichtungen} an der Universit"at Stuttgart kurz als
``Offener Antrieb'' bezeichnet.

Die hardwaretechnische Realisierung erfolgt in Form einer Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX'' Baustein. Es
handelt sich dabei um ein CPLD\footnote{Complex Programmable Logic Device},
das sich frei programmieren l"asst. Der Anwender hat die M"oglichkeit, die
Funktion des Bausteins seinen Bed"urfnissen anzupassen.

Um die Offenheit f"ur jeden Anwender nutzbar zu machen, wird f"ur das CPLD eine
Architektur festgelegt, die es erm"oglicht, einzelne Funktionalit"aten in Form
von Bl"ocken zu implementieren. Diese Bl"ocke k"onnen aus festprogrammierten
Schaltungen (Cores) oder freiprogrammierbaren CPUs bestehen. Die
Signale können über ein freiprogrammierbares Netzwerk verbunden
werden. 

Diese komplexe Netzwerke auf einer von der Hardware abstrahierten
Ebene für den Anwender einfach programmierbar zu machen ist die
Kernanforderung des POA Projekts. 

\section{Anforderungen}

Aus dem im vorherigen Abschnitt skizierten Projekthintergrund ergaben
sich folgende Anforderungen im Detail, deren Umsetzung auch in einem
Angebotsdokument verbindlich mit dem Auftraggeber vereinbart wurden:

\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Bearbeitung einer CPLD-Blockbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung f"ur eingebette CPU-Bl"ocke in einem CPLD-Layout
\item Plausibilit"atspr"ufung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen von Quellcode f"ur die CPU-Bl"ocke
\item Speichern und "Offnen von CPLD-Layouts und zugeh"origem Quellcode
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}

Diese Anforderungen wurden im Laufe des Projekts vollständig
implementiert. Darüberhinaus wurden folgende zusätzliche Anforderungen
umgesetzt: 

\begin{itemize}
\item Automatisches Routing von Verbindungen zwischen Blöcken
\item Drucken von Netzwerken
\item Vergrössern und verkleinern der Netzwerk ansicht
\item Automatische Signal-Laufzeitoptimierung
\item Öffnen mehrerer Projekte zur gleichen Zeit mit
  Datenaustauschmöglichkeiten über die Zwischenablage
\item Anzeige der Taktfrequzenzen mittels Einfärbung der Blöcke
\item Lokalisierung in Deutsch und Englisch
\item Lauffähigkeit unter Microsoft Windows und Linux
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektergebnisse}

\section{Programmierumgebung Offener Antrieb}

Aus den genannten Anforderungen resultierte die ``Programmierumgebung
Offener Antrieb'', kurz POA. POA ist eine Applikation mit grafischer
Oberfl"ache basierend auf der QT Bibliothek von Trolltech. Die
Bedienung erfolgt intuitiv mit Drag-and-Drop. Aus der Bibliothek auf
der linken Seite können vorgefertigt konfigurierte Blöcke auf die
Arbeitsoberfläche gezogen werden und in einem Dialog konfiguriert
werden. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{poa}
  \caption{Hauptfenster}
\end{figure}

Einstellbar sind Parameter wie die Taktrate, Laufzeit und die Anzahl
der Pins über die andere Blöcke vernetzt werden können. CPUs bieten
außerdem die Möglichkeit über den Aufruf eines externen Editors
Quellcode zu Hinterlegen, der auf der CPU ausgeführt wird, nachdem der
Download des Projekts auf den CPLD erfolgt ist. Wenn mehrere Blöcke
auf der Arbeitsoberfläche plaziert wurden, können diese mit der Maus
an ihren Pins verbunden werden.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{blockconfiguration}
  \caption{Block Konfigurationsdialog}
\end{figure}

Sobald ein Projekt fertig gestellt ist, kann die Laufzeit eines oder
mehrerer Signale nach einer priorisierten Liste optimiert werden. Ein
Signal entspricht der Berechnung eines Ausgangswertes aus einem
Eingangswert. Eingangswerte werden durch Eingangsblöcke representiert
und der Signalweg durch die Verbindung von Blöcken festgelegt. Durch
Berechnung eines optimalen Offsets für die Taktung eines Blocks kann
nun erreicht werden, dass ein bestimmtes Signal in kürzest möglicher
Zeit das Netzwerk durchläuft.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{scheduling}
  \caption{Scheduling Dialog}
\end{figure}

Nach der Optimierung der Signallaufzeiten kann das Projekt auf einen
CPLD übertragen werden. Bisher ist nur der Download des kompilierten
Quellcodes einer einzelnen CPU möglich, da hardwareseitig bisher keine
Unterstützung für mehrere CPUs vorgesehen ist.  

Vor der Übertragung wird das Projekt auf Konsistenz geprüft

Eine vollständige Beschreibung von POA befindet sich im Handbuch.

\subsection{Technische Umsetzung}

Die Architektur von POA lässt sich in stark zusammenhängende Module
aufteilen, die eine gerine Kopplung aufweisen. Der POA Entwurf wurde
nach folgenden Kritieren optimiert:

\begin{itemize}
\item Leichte Erweiterbarkeit
\item Hohe Änderbarkeit
\end{itemize}

Erreicht wurden diese Eigenschafen in erster Linie durch ein einfaches
Design. Es wurden nur die notwendigen Klassen implementiert, keine
Technologie auf Vorrat angelegt. Soweit möglich wurden Entwurfsmuster
verwendet, um das einfache Verständnis des Quellcodes zu erhöhen. Es
wurden unter anderen das Model-View-Controller, Strategie und das
Singletonmuster benutzt.

\section{Dokumente}

\subsubsection{Angebot}

Neben der Programmierumgebung sind ist im Laufe des Projekts
Dokumentation entstanden. In einem knapp 20-seitigen Angebot wurden
die Anforderungen und ein Projektablaufplan mit dem Auftraggeber
vereinbart. 

\subsubsection{Entwurf}

Der Entwurf der ersten Version entstand in Form von Quellcode Dateien,
die Klassendeklarationen ohne Programmlogik enthielten. Zum Ende des
Projekts wurde die Architektur der letzten Version in einem Form eines
Dokuments beschrieben. Dieses Dokument soll bei einer möglichen
Weiterentwicklung der Software als Orientierungsshilfe dienen. Das
Entwurfsdokument wird durch ein A0 Poster, das die gesammte
Klassenstruktur als UML Diagramm zeigt, ergänzt.

\subsubsection{Handbuch}

Dem Benutzer steht ein 40-seitiges mit Bildschirmfotos illustriertes
Handbuch zur Verfügung. Das Handbuch enthält einen Referenzteil, der
der die Programmdialoge beschreibt und ein Tutorial, das dem
unerfahrenen Benutzer anhand eines Beispeils einen leichten Einstieg
in die Bedienung von POA ermöglicht.

\subsubsection{Interne Dokumente}

Einige Dokumente wurden nur innerhalb des Teams verwendet und nicht an
den Auftraggeber ausgeliefert. Zu nennen ist hier eine Spezifikation,
die in Form von Benutzungsfällen den Funktionsumfang der ersten
Version beschreibt, Kodierungsrichtlinen im Rahmen des
Konfigurationsmanagements und der Testbericht des Systemtests.

\section{Weitere Ergenisse}
\label{gcover}

\subsection{GCover}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{gcover}
  \caption{HTML-Ausgabe von GCover}
\end{figure}

Im Rahmen des POA Projekts entstand als Nebenprodukt eine Software zur
Auswertung der von dem Werkzeug gcov ermittelten Testüberdeckung. Gcov
ist Teil der GNU gcc Kompilersuite, die zur Übersetzung von POA
verwendet wurde. Gcov annotiert im wesentlichen die einzelnen
Quellcodezeilen mit einer Zahl, die angibt wie oft die Zeile
ausgeführt wurde. Zusätzlich wird auf der Konsole pro Datei ausgegeben
wie hoch die Zweigüberdeckung ist. Die Auswertung der gcov Ausgabe ist
umständlich und wird deswegen von Entwicklern oft gemieden. 

Um die Ergebnisse anschaulich und einfach verfügbar zu machen, wurde
gcover in der Sprache Java entwickelt. GCover wertet die Ausgabe von
gcov aus und stellt die Anweisungsüberdeckung in einem HTML Frameset
ähnlich des verbreiteten JavaDoc von Sun dar.

GCover generiert eine Übersichtsseite, die die Anweisungs- und
Zweigüberdeckung aller Dateien anzeigt. Bei Auswahl einer Datei wird
der Quellcode der Datei angezeigt. Die Zahl in der linken Spalte gibt
die Zeilennummer und die Anzahl der Ausführungen der jeweiligen Zeile
an. Nicht überdeckte Zeilen werden rot unterlegt.

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{gcover-file}
  \caption{Anweisungsüberdeckung einer einzelnen Datei}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektorganisation}

\section{Projektrahmen}

Auftraggeber, Auftragnehmer

\section{Das Team}

Das Team bestand aus sieben Studenten der Software-Technik, die zu
Beginn des Projekts im sechsten Semester studierten. 

\begin{itemize}
\item Necati Aydin
\item Anselm Garbe
\item Stefan Hauser
\item Steffen Keul
\item Marcel Kilgus
\item Steffen Pingel
\item Tammo van Lessen
\end{itemize}


\subsection{Rollen}

Formale Rollen wurden mangels Notwendigkeit nur wenige festgelegt. 

\subsubsection{Projektleiter}

Der Projektleiter war für den Kontakt mit dem Kunden und für die
Koordination des Teams zuständig. 

Die Rolle des Projektleiters wurde von Steffen Pingel übernommen.

\subsubsection{Konfiguationsmanager}

Der Konfiguationsmanager war für die Verwaltung des zentralen
Repositories in dem sowohl die Dokumente als auch der Quellcode
gespeichert wurde zuständig. 

Desweiteren wurden vom Konfiguationsmanager Richtlinien zur
Formatierung des Quellcodes und zur Benutzung des Repositories
erstellt. 

Die Rolle des Konfiguationsmanagers wurde von Anselm Garbe übernommen.

\subsubsection{Entwickler}

Die Aufgabe der Entwickler war die Erstellung des Quellcodes und das
Verfassen der Dokumente.

Die Rolle der Entwickler wurde von allen Teilnehmern belegt.

\section{Entwicklungsphilosophie}

- GPL
- Transparenz


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektablauf}

\section{Prozessmodell}

Als Prozessmodell wurde ein iteratives Phasenmodell gewählt wobei
nicht alle Phasen in den einzelnen Iterationen ausgeführt wurden. Die
Anforderungsanalyse-, Spezifikations- und Entwurfsphase wurden nur zu
Beginn des Projekts einmalig durchlaufen. Auch ein Gesammttest wurde
nur zum Ende des Projekts ausgeführt. 

Die einzelnen Iterationen, genannt Sprints, bestanden jeweils aus
einer Anforderungsanalyse-, Entwurfs- und Kodierungsphase, die von
einem kontinuierlichen Regressionstest begleitet wurde. Zu Ende jeder
Iteration wurde das weiter entwickelte Produkt ausgeliefert und vom
Kunden einem Akzeptanztest unterzogen. 

Das Prozessmodell wurde gewählt um dem Forschungscharakter des
Projekts gerecht zu werden. Zu Begin des Projekts war unklar wie
stark sich die Anforderungen während des Projekts ändern
würden. Deswegen wurde zu Beginn jeder Iteration

...and here the tale suddenly ended. Which reminds me of this:

\begin{verbatim}
MAYNARD:  It reads, 'Here may be found the last words of Joseph
    of Aramathea.  He who is valiant and pure of spirit may find
    the Holy Grail in the Castle of uuggggggh'.

ARTHUR:  What?

MAYNARD: '... the Castle of uuggggggh'.

BEDEMIR:  What is that?

MAYNARD:  He must have died while carving it.

[Monthy Python and the Holy Grail]
\end{verbatim}

\section{Projektplan}

Der ursprünglich im Angebot vorgesehe Zeitplan diente als grobe
Orientierung für den Projektverlauf. Die Planung und Ausführung war im
wesentlichen von einer Hausmesse am ISW und dem Ablauf der Semesters
geprägt. 

Die ursprünglich geplanten fünf Sprints wurden auf drei Reduziert. Zum
Einen stellte sich während des Projekts heraus, das die Anforderungen
abgesehen von kleinen zusätzlichen funktionalen Anforderungen
weitgehend stabil waren. Zum Anderen war der zeitliche Aufwand,
bedingt durch organisatorische Tätigkeiten wie eine
Produktpräsentation am Ende jedes Sprints höher als erwartet. 

Die vereinbarten Meilensteine wurde eingehalten bzw. im mit dem
Einverständnis des Kunden geringfügig verschoben. 

Als Schwierig erwiess sich die Koordination der individuellen
Wochenpläne. Bedingt durch unterschiedlich gewählte Vorlesungen,
andere Studienprojekte, Urlaubsplanung, Krankheit und
Nebenbeschäftigungen war es kaum möglich gemeinsame Termin zu finden.
Dennoch wurde sowohl während Entwicklung des Prototypen in der
vorlesungsfreien Zeit und während der Sprints in der Vorlesungszeit
Kernarbeitszeiten eingeführt, die die Kommunikation stark erleichtert
haben.

Die Kernarbeitszeiten wurden während des Projekts durch Treffen des
Teams in entspannter Athmosphäre ergänzt. Während der Treffen wurde
von den Teilnehmern über den Fortschritt berichtet und anstehende
Aufgaben verteilt. 

\subsubsection{Ursprünglicher Zeitplan}

\begin {center}
  \begin {tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Termin} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 200 & KW 25 & M1: Angebot \\
     2 & Spezifikation & 300 & & \\
     3 & Entwurf & 300 & & \\
     4 & Prototyp Messe & 300 & 1.10.2003 & M2: Prototyp Messe \\
     5 & Prototyp Erweitert & 300 & 10.11.2003 & M3: Prototyp Erweitert \\
     6 & Sprint 1 & & KW 48 - 51 & \\
     7 & Sprint 2 & & KW 2 - 6 & \\
     8 & Sprint 3 & & KW 8 - 12 & \\
     9 & Auslieferung und Präsentation & & 1.4.2004 & M4: Auslieferung\\
    \hline
       & & 1400\\
  \end {tabular}
\end {center}

\subsubsection{Projektablauf}

\begin {center}
  \begin {tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Termin} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 200 & KW 25 & M1: Angebot \\
     2 & Spezifikation & 300 & & \\
     3 & Entwurf & 300 & & \\
     4 & Prototyp Messe & 300 & 1.10.2003 & M2: Prototyp Messe \\
     6 & Sprint 1 & & KW 48 - 51 & \\
     7 & Sprint 2 & & KW 2 - 6 & \\
     9 & Auslieferung & & 26.3.2004 & M4: Auslieferung\\
     9 & Nachbesserung & & 19.4.2004 & \\
     9 & Abschlusspräsentation & & 1.6.2004 & \\
    \hline
       & & 1400\\
  \end {tabular}
\end {center}

\subsection{Anforderungsanalyse}

Während der Anforderungsanalyse wurde Anforderungen des Kunden
ermittelt. Die Ergebnisse wurden in einem Angebot dokumentiert, das
dem Kunden zur Abnahme vorgelegt wurde. Das Angebot beinhaltete
ausserdem eine Zeitplan und eine Beschreibung des geplanten
Projektablaufs. 

\subsection{Spezifikation}

Die Spezifikation beinhaltete Benutzungsfälle und wurde als internes
Dokument zur Erstellung der Benutzungsoberfläche verwendet.

\subsection{Entwurf}

Im Grobentwurf wurde die Architektur festgelegt und die Schnittstellen
des Datenmodells in Form von Headerdateien entwickelt.

\subsection{Prototyp (Erste Iteration)}

Der Prototyp wurde für eine Hausmesse am ISW entwickelt. Der Prototyp
wurde für die Präsentation des Offenen Antriebs verwendet. Der Focus
lag auf der Entwicklung der graphischen Benutzungsoberfläche, die
teilweise funktionslose Dialoge beinhaltete. 

Die zeitgemässe Auslieferung des Prototypen und die damit verbundene
Erreichung des zweiten Meilensteins war auch ein erster Test, ob die
Umsetzung der Anforderungen mit den Vorstellung des Kunden
übereinstimmte. Da sich die Rückmeldungen des Kunden als sehr positiv
erwies, wurde die Entscheidung getroffen den Prototyp nicht zu
verwerfen sondern als Basis weiter zu verwenden. Somit kann die
Entwicklung des Prototypen als erste Iteration bezeichnet werden. 

\subsection{Zweite Iteration}

Zu Beginn des ersten Sprints wurde ein Refaktorisierung des Quellcodes
vorgenommen, um die während der Entwicklung des Prototypen entdeckten
Schwachstellen des Entwurfs zu beseitigen. 

Desweiteren wurden Funktionalitäten, die im Prototypen nur als Dialoge
zur Verfügung standen implementiert. 

Zum Ende des erstens Sprints wurde das bisher nur unter Linux
entwickelte Produkt auf Microsoft Windows portiert. Neben einigen
syntaktischen Korrekturen, die in Unterschieden zwischen den
verwendeten Compilern begründet sind, mussten kleinere
plattformspezifische Eigenheiten von QT umschifft werden.

Die Portierung, die oben beschriebene Refaktorisierung und die
zweiwöchigen Weihnachtsferiern haben zu der Ausdehnung der Iteration
bis in den Januar geführt. 

\subsection{Dritte Iteration}



\subsection{Auslieferung}

\subsection{GCover Unterprojekt}

\section{Zeitverteilung}

Die Zeitaufwände der einzelnen Entwickler waren homogen verteilt.

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{zeitverteilung}
  \caption{Zeitliche Aufwandsverteiung auf die Entwickler}
\end{figure}

Bei den Tätigkeiten überwiegt der Anteil der Implementierung. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{phasenverteilung}
  \caption{Zeitliche Aufwandsverteiung auf die Phasen}
\end{figure}

\section{Werkzeuge}

Für die Entwicklung wurden zahlreiche Werkzeuge eingesetzt. Die Wahl
war den Entwicklern freigestellt solange die vereinbarten Richtlinien
eingehalten wurden. Bei der Wahl von Dokumentenformaten wurde darauf
geachtet, dass für alle eingesetzten Platformen freie Werkzeuge zur
Bearbeitung verfügbar waren.

\subsubsection{Maven}

Besondere Erwähnung soll das Werkzeug Maven finden. Maven wurde für
die Generierung der Projektseite im Internet benutzt. Maven bietet
die Möglichkeit eine anschauliche Projektdokumentation auf einfache
Art und Weise zu erstellen. Die Dokumentation enthält unter anderem
Informationenn über die Entwickler, den Quellcode und die
Projektablauf. Damit konnte sowohl für den Kunden als auch für die
Entwickler eine hohe Transparenz erreicht werden.

\subsubsection{Berlios}

Verwaltet wurde das Projekt auf der Open-Source Platform Berlios, die
vom Frauenhofer Institut betrieben wird. Berlios bietet vielfältige
Unterstützung wie z.B. eine Internetseite, einen Downloadbereich,
Mailinglisten und ein Repository. Zu dem Bedauern des Teams ließ die
Verfügbarkeit von Berlios in den letzten Wochen des Projekts stark zu
wünschen übrig und erschwerte so den Informationsaustausch.

\subsubsection{Jira}

Die Tracker Funktionalität von Berlios wurde nicht
benutzt. Stattdessen wurde Jira von Atlassian eingesetzt, die
freundlicherweise eine kostenlose Lizens für das POA Projekt zur
Verfügung stellten. Jira ermöglicht eine detailierte Erfassung von
Aufgaben und Fehlerberichten inklusive einer Zeitabschätzung und
Fortschrittserfassung. Letzters war sehr hilfreich bei der Planung und
Kontrolle der Sprints.

\subsubsection{StatCVS-XML}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Statistische Analyse}



\section{Versions Kontrolle}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{loc}
  \caption{Quellcode Zeilenanzahl über die Zeit}
\end{figure}

Das Diagramm zeigt die gesammte Zeilenanzahl inklusive aller
Kommentarzeilen über die Laufzeit des Projekts. Die vertikalen
gestrichelten Linien geben die Versionsmarkierungen an, zu diesem
Zeitpunkt wurde jeweils eine lauffähige POA Version an den
Auftraggeber ausgeliefert.

An dem Diagramm lassen sich sehr gut die Iterationen ablesen. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{size_by_module}
  \caption{Verteilung der Quellcode Zeilenanzahl auf die Module}
\end{figure}

\begin{figure}[h!]
  \centering
  \begin {tabular}[l]{ll}
    \hline
    Dateiname & Entwickleranzahl \\
    \hline
    src/poa.cpp & 6 \\
    src/mainwindow.cpp & 6 \\
    src/librarywindow.cpp & 6 \\
    src/blockmodel.cpp & 6 \\
    src/settings.h & 5 \\
    src/scheduledialog.cpp & 5 \\
    src/project.h & 5 \\
    src/project.cpp & 5 \\
    src/poa.h & 5 \\
    src/pinview.h & 5 \\
    \hline
  \end {tabular}
  \caption{Anzahl Entwickler pro Datei (Top 10)}
\end{figure}


\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{commit_by_hour}
  \caption{Uhrzeiten der CVS Repository Aktivitäten}
\end{figure}


\subsection{Evolution}

\begin{figure}[h!]
  \centering
  \includegraphics[height=20cm]{evolution}
  \caption{Änderungshistorie der Versionen}
\end{figure}

\section{Metriken}

\subsection{Testüberdeckung}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Persönliche Berichte}

\section{Necati Aydin}
\section{Anselm Garbe}

\subsection{Tätigkeiten}
Seit Projektbeginn war ich neben den allgemeinen
Entwicklunstätigkeiten für das Configuration Management verantwortlich,
welches die Aufstellung von Richtlinien zur Toolunterstützung, u.a. zu
CVS, ssh und TeX beinhaltete, sowie die Pflege und Wartung des
Projekt-Repositories und der Mailinglisten. Die Pflege des
Projektrepositories und der Mailinglisten waren eine permanente Aufgabe
bis zum Projektende. Hierzu gehörte u.a. auch die Sicherung von
automatischen Backups zu POA.

Am Projektbeginn war ich an der Spezifikations- und Angebotserstellung
beteiligt, vor allem mit dem Fokus auf die GUI und Codegenerierung.
Grundlage des Angebotes und der Spezifikation war eine detaillierte
Anforderungsanalyse die durch verschiedene Kundengespräche durchgeführt
wurde.

Zusammen mit Steffen Keul erstellte ich einen Grobentwurf, der
grundlegend das MVC Design Pattern propagierte, dass integraler
Bestandteil von POA während der gesamten Entwicklung blieb.

Aufgrund meiner C++ Kenntnisse aus der Zeit vor meinem Studium, die auch
verschiede windows-basierte GUI Anwendungen zur Folge hatten sowie aufgrund
meiner C Kenntnisse aus einem OpenSource Projekt wählte ich als
Seminarthema das ``Qt Toolkit'' welches eine portable OpenSource
Plattform (für nicht-kommerzielle Projekte) bietet, die unter Windows,
Unix und Mac OS X lauffähig ist und dem POA Team einen initialen
Anleitungsfaden vermitteln sollte.

Zu Beginn der Implementierungsphase in der ersten Iteration entwickelte
ich zusammen mit Steffen Pingel eine Qt-basierte POA Rahmenanwendung,
die eine MDI (Multiple Document Interface) Architektur 
sowie den qmake-basierten Buildprozess unterstützte.
Zu dieser Zeit evaluierte ich auch, dass wir auf die
Entwicklungsunterstützung durch den Qt (GUI) Designer verzichten, da
dieser nur absolute Widget-Positionierung unterstützt und 
umständlichen Code generiert - die GUI Entwicklung im POA Projekt fand
weitestgehend ohne Unterstützung des Qt Designers statt bzw. ist in der
Rückbetrachtung vollkommen unabhängig von diesem verlaufen.

Während der Implementierungsphase war ich für die Entwicklung des
Block-Konfigurationsdialoges, sowie des (De)Mux-Konfigurationsdialoges
zuständig, sowie mit der Integration der damit zusammenhängenden Models
(CPU-, Block-, Mux- und PinModel). Darüber hinaus entwickelte ich den
CodeManager für die Konfiguration und Editierung von CPUs. Dieser führt
automatische Substitutionen des Quellcodes durch, der alle Ein- und
Ausgänge (Pins) der CPU-Konfiguration als Variablen (NIOS Address
Pointer) zur Verfügung stellt. Hierzu zählte auch die Entwicklung eines
internen Ausgabeterminals, das Compiler-Ausgaben in einen POA Dialog
umleitet, um den Status und Fortschritt der Compilierung des Quellcodes
einer CPU zur Verfügung stellt.

Neben meiner Entwicklungstätigkeit nahm ich auch an verschiedenen
Reviews des Quellcodes und des Handbuchs teil, die zur
Qualitätssicherung durchgeführt wurden.

\subsection{Beurteilung}

Rückblickend betrachtet verlief die POA Entwicklung ohne nennenswerte
Konflikte im Team. Die Zusammenarbeit mit den anderen Entwicklern war
durchweg harmonisch. Trotz der weitestgehend autonomen
Entwicklertätigkeiten funktionierte die Modulintegration durch kurze
Absprachen sehr gut, mir ist rückblickend fast kein Zeitpunkt bekannt,
an dem die POA Applikation im CVS nicht compilierfähig gewesen wäre.

Ich empfand die durchweg kollegiale und lockere Entwicklerführung durch
den Projektleiter Steffen Pingel als angenehm und motivierend.
Alle Entwickler konnten aufgrund der nur kurzen Kernarbeitszeit ihre
Aufgaben weitestgehnd autonom lösen. Neben der eigentlichen
Entwicklertätigkeit trafen sich die Entwickler auch spontan zu privaten
Arrangements.

Aus ökonomischer Sicht stellt sich mir durch Vergleiche mit
kommerziellen Projekten durch meine werkstudentische Tätigkeit sowie
meines viermonatigen Industrtiepraktikums bei der
Firma Danet IS GmbH in Stuttgart die POA Entwicklung als voller Erfolg
dar, da der Zeitrahmen nicht überzogen wurde und somit sich die Kosten im
Rahmen des für Studienprojekte vorgesehenen Zeitaufwands beliefen.

Das die POA Entwicklung ein voller Erfolg war dürfte vor allem auf die
Team-Zusammensetzung zurückzuführen sein.

\section{Stefan Hauser}

\subsection{Team}
Das POA-Team war eine Gruppe, deren Teilnehmer sehr unterschiedliche 
Startvoraussetzungen hatten: Etwa die H"alfte des Team war Mitten im 
Studienprojekt A, also in der heißen Codierungsphase. Die andere
H"alfte hat mit dem Studienprojekt B zuerst begonnen und bisher noch 
keine Erfahrungen mit Projekten dieser Gr"oße. Auch das technische
Wissen war unterschiedlich: Ein Teil des Teams beherschte C++ schon 
perfekt, f"ur die anderen war dies noch Neuland. \newline

Da ich mit POA mein erstes Studienprojekt bestritt und bisher noch
keine Erfahrungen in C++, jedoch aus dem vorangegangenen
Software-Praktikum in Java hatte, erhoffte ich mir zu Beginn
des Projekts einen großen Wissensgewinn, durch den Know-How-Transfer
zwischen des Team-Mitgliedern. \newline

Die Entscheidung f"ur POA war aus meiner Sicht die richtige, denn wir 
bildeten ein schlagkr"afiges Team und auch der Kontakt mit Christian
Kramer war kollegial, immer schnell hergestellt und
unproblematisch. Der hervorragende Projektverlauf spiegelt sich auch
darin wieder, dass wir nie auf die Hilfe unseres Betreuers angewiesen
waren, sondern alle Problemstellungen selbst"andig oder in Absprache
mit Christian Kramer l"osen konnten.\newline

\subsection{Seminar}
Meine Seminararbeit besch"aftigte sich mit den M"oglichkeiten des
manuellen und automatischen Routens von Leiterbahnen zwischen
Funktionsbl"ocken auf Platinen. Also dem Erstellen eines
Platinenlayouts. Mein erster Ansatz den ich verfolgte, war die Idee,
das Routing mit Hilfe eines evolution"aren Algorithmuses automatisch 
durchzuf"uhren. Dieses Konzept stellte ich im ersten Teil der
Seminararbeit vor. Doch ich verwarf die Idee wieder, da sich die
Algorithmen zwar auf verschiedene Kriterien, wie zum Beispiel minimale 
Platinenfl"ache oder k"urzeste Leiterwege, optimieren lassen, wir
jedoch f"ur unsere Anwendung eine Optimierung zur leichten
Verst"andlichkeit der Schaltung, also einer gute Darstellung
w"unschten, was sich aber nicht algorithmisch ausdr"ucken l"asst. 
Der zweite Teil der Seminararbeit besch"aftigte sich somit mit den 
M"oglichkeiten des manuellen Routings und welche Techniken zum
Beispiel in CAD-Anwendungen verwendet werden um den Benutzer dabei zu 
unterst"utzen. Die Arbeit schließt dann mit der Vorstellung eines
Konzepts zur konsistenen Speicherung des Layouts. \newline

POA sieht in Version 1.0 "ubrigens auch ein automatisches Routing
vor. Die Idee, die hier dahinter steckt  ist, das ein
"uberkreuzungsfrei gezeichneter, sprich planarer Graph leichter 
verst"andlich ist, als einer indem sich die Leitungen "uberkreuzen und
darauf, dass die Positionen der Funktioinsbl"ocke beim Routing als vom 
Benutzer fest vorgegeben  angenommen werden.\newline

\subsection{Aufgaben}
W"ahrend der Angebotserstellung habe ich zusammen mit Anselm Garbe
eine Anforderungsanalyse durchgef"uhrt, das Mengenger"ust erstellt und 
am Begriffslexikon mitgearbeitet. Schließlich entwarf ich einen
funktionslosen Prototypen der Benutzungsoberfl"ache, der so auch in
der ersten Iteration von POA umgesetzt wurde. W"ahrend der
Entwurfsphase wirke ich in Reviews mit.\newline

Bei der Codierung beteiligte ich mich bei der Erstellung der 
Benutzungsoberfl"ache und erstellte die erste Version der 
``Deploy-Projekt''-Funktionalit"at, zu der auch die M"oglichkeit
geh"rt, den Quellcode zu compilieren und auf den ``Offenen Antrieb'' 
herunterzuladen und auszuf"uhren. Dazu wurde bisher ein keines
C-Programm verwendet, das jedoch plattformabh"angig war und nicht
unter Linux lief. Ziel war es den Download in POA so zu
implementieren, dass er sowohl unter Linux als auch unter Windows die 
serielle Schnittstelle  zum herunterladen des ausf"uhrbaren Programms 
verwenden konnte. Dazu forschte ich nach eine frei erh"altlichen
Bibliothek f"ur QT, die plattformabunabh"angigen zugriff auf die
serielle Schnittstelle erm"oglicht und wurde in QExtSerialPort
f"undig. Mit Hilfe dieser Bilbliothek konnte der Download in POA 
platformunabh"angig realisiert werden.\newline

Anschließend implementierte ich die Funktion, die in POA verwendete
Sprache zu "andern. Dazu  passte den vorhandenen Code, soweit noch
nicht geschehen, f"ur die Verwendbarkeit mit mehreren Sprachen an und 
"ubersetzte alle Texte vom englischen ins deutsche.\newline

Schliesslich f"uhrten wir einige Code-Reviews durch, an denen ich
ebenfalls teilnahm und beschlossen noch weitere Test von der
Oberfl"ache aus durchzuf"uhren, da dieser Teil bei den bisherigen
Tests mit gcov noch nicht ausreichend abgedeckt war. Dazu erarbeitete
ich eine Reihe von Testf"allen, entwickelte einen Testplan und f"uhrte 
die Tests durch.\newline

Gegen Ende des Projekts nahm ich noch an Handbuch-Reviews teil und
habe die CD erstellt sowie verschiedene Dinge f"ur den
Abschlussbericht und die Abschlusspr"asentation erledigt.\newline

\subsection{Fazit}
Meine Erfahrungen, sowohl ``soft skills'', als auch Kenntnisse "uber 
Werkzeuge, die wir w"ahrend unseres Projekts verwendet haben (z.\ B. 
LaTeX, das Zeiterfassungstool oder CVS) kann ich jetzt in meinem
zweiten Projekt, dass inzwischen schon ein halbes Jahr l"auft,
einbringen. Dort bin ich der einzige, der schon Softwareprojekt-
Erfahrungen hat und kann dementsprechend oft den entscheidenen Tipp
f"ur oder gegen ein bestimmtes Vorgehen oder zu verwendetes Werkzeug
geben. Insofern kann ich schon jetzt vom meinem erlangten Wissen
porfitieren, ein wirklich positives Fazit ziehen und mich bei allen 
Team-Mitgliedern f"ur die gute Zusammenarbeit bedanken.


\section{Steffen Keul}

\subsection{Aufgaben}

Zu Beginn des Projekts wurden keine bestimmten Rollen zugewiesen. Es
war vielmehr eine Anforderung an jedes Team-Mitglied, den Überblick
über das gesamte Projekt zu behalten und bei Bedarf an bestimmte
Detailproblemen arbeiten zu können.

\subsection{Tätigkeiten}

\subsubsection{Seminar}

In meinem Seminarvortrag untersuchte ich das Problem der Berechnung
eines optimalen Scheduling für die POA-Plattform. Da für die
speziellen Anforderungen des Offenen Antriebs keine bekannten Lösungen
existieren, analysierte ich die genauen Anforderungen an eine
algorithmische Lösung des Problems. Diese Anforderungsanalyse diente
später als Grundlage für die Implementierung von POA.

\subsubsection{Anforderungsanalyse}

Während der Anforderungsanalyse nahm ich an allen Kundengesprächen und
internen Besprechungen teil.

\subsubsection{Entwurf}

Gemeinsam mit Anselm Garbe erstellte ich einen Grobentwurf für das
POA-System. Die Tauglichkeit unseres ersten Vorschlags wurde dann in
einer Review-Sitzung evaluiert und wir konnten noch einige
Vereinfachungen in den Entwurf integrieren.

Das Ergebnis des Entwurfs waren kommentierte Klassendeklarationen, die
während der Implementierung in die POA-Codebasis übergingen. Die
grundlegende Struktur des Entwurfs ist im fertigen Produkt erhalten
geblieben.

\subsubsection{Implementierung}

Zu Beginn der Implementierung nahm ich vielfältige Funktionen
war. Diese schlossen diskussionen über die Programmiersprache C++ ein
sowie die konkrete Gestaltung des Codes, um Konformität zu dem Entwurf
sicher zu stellen. Die Sprache C++ wird im Grundstudium der
Softwaretechnik nicht gelehrt und war deshalb für einige
Team-Mitglieder neu. Ich selbst hatte zwar vor Beginn meines Studiums
schon einige Jahre damit gearbeitet, musste mein Wissen aber zu Beginn
des Projekts etwas auffrischen.

Im weiteren Verlauf des Projekts wendete ich mich zunehmend den
algorithmisch aufwändigeren Problemen des Projekts zu. Ich entwarf und
implementierte zwei verschiedene Verfahren zur automatischen
Layoutberechnung und den Algorithmus zur automatischen Berechnung des
Scheduling.

Das erste Verfahren zur Layoutberechnung basiert auf einer Sequenz von
Entscheidungen und berechnet in konstanter Zeit ein Layout für einen
eizelnen Konnektor. Dieses Verfahren ist extrem effizient und kann
angewendet werden, während ein Block verschoben wird um die
verbundenen Konnektoren entsprechend anzupassen.

Das zweite Verfahren basiert auf dem bekannten Algorithmus von
Dijkstra. Dieses Verfahren wird angewendet, um einen einzelnen
Konnektor in ein bestehendes Netzwerk zu integrieren. Dabei wird der
neue Konnektor mit einer minimalen Anzahl an Kreuzugen mit anderen
Objekten und einer minimalen Anzahl an Knickpunkten gezeichnet.

Zur Berechnung eines optimalen Scheduling für POA konnte ich in der
Literatur kein geeignetes Verfahren finden. Für meinen Seminarvortrag
hatte ich eine Lösung entworfen, die sich einem evolutionären
Verfahren bedient. Mit dem Fortschritt des Projekts hatte ich aber
einen besseren Einblick in potenzielle Anwendungen von POA gewonnen und
konnte eine weniger rechenaufwändige Lösung finden, die für die
meisten Netzwerke trotzdem optimale Ergebnisse berechnet.

Der Benutzer kann eine Liste von priorisierten Wegen durch das
Netzwerk vorgeben, die in der angegebenen Reihenfolge optimiert
werden. Der erste Weg wird garantiert eine minimale Signallaufzeit
erhalten. Für die weiteren Wege der Liste kann das Ergebnis durch die
bereits berechneten Eigenschaften der voherigen Wege verschlechtert
werden. In den getesteten Beispielen konnte stets ein optimales
Scheduling gefunden werden. Die konkrete Implementierung des
Verfahrens lässt auch zu dass Parameter einzelner Blöcke manuell
vorgegeben werden und nicht das gesamte Scheduling automatisch
berechnet wird.

\subsubsection{Validierung}

Ich erstellte Testprogramme für die Teile meines Codes, bei denen ein
automatischer Test sinnvoll erschien. Für das automatische Scheduling
oder das automatische Layout wäre ein automatisierter Test jedoch
nicht machbar gewesen. Es ist kaum möglich, automatisiert
festzustellen, ob ein Layout den Anforderungen entspricht oder ob ein
Scheduling tatsächlich optimal ist. Stattdessen führte ich durch
systematisches Ausprobieren des Programms einen explorativen Test
durch.

Außerdem führten wir Code-Reviews durch an denen ich als Gutachter
sowie als Autor beteiligt war. In diesen Reviews konnten einige Fehler
identifiziert und später beseitigt werden.

\subsection{Einschätzung des Projekts}

Ich werte POA als Erfolg. Die Anforderungen an POA waren zu keinem
Zeitpunkt klar fixiert, sondern POA war Teil eines größeren Projekts
dessen Richtung noch nicht bis ins letzte Detail feststand. Das von
uns angewendete Prozessmodell halte ich deshalb für richtig gewählt,
da es uns ermöglichte, dem Kunden erste Ergebnisse zu präsentieren und
dann aufgrund seines Feedbacks das weitere Vorgehen anzupassen.

Die Arbeit im Team empfand ich als sehr angenehm. Die einzelnen
Team-Mitglieder waren kompetent und hilfsbereit. Die Projektleitung
ging auf individuelle Eigenschaften der Entwickler ein und führte das
Team ohne einschränkend zu wirken. Der Kontakt zum Kunden war direkt
und unkompliziert.


\subsection{Persönlicher Lernerfolg}

Als Ergänzung zu den Vorlesungen im Anwendungsfach gewann ich durch
das Projekt einen besseren Einblick in die Regelungstechnik und den
Aufbau eines Regelkreises.

Ich lernte das Toolkit Qt kennen. Ich hatte Gelegenheit mich mit
algorithmischen Aufgabenstellungen aus der Praxis auseinander zu
setzen. Hier konnte ich den Nutzen meiner theoretischen Ausbildung
erproben, da sich diese Probleme zumindest teilweise auf
Standardalgorithmen zurückführen ließen.

Schließlich fand ich es interessant, ein iteratives Prozessmodell zu
erleben. Obwohl ich dieses Vorgehen nach wie vor nicht für optimal
halte, fand ich es sehr lehrreich mich mit Vor- und Nachteilen dieses
Vorgehens in der praktischen Anwendung auseinader zu setzen.



\section{Marcel Kilgus}
\subsection{Aufgaben}
Aufgrund meiner weit über 10 Jahre Erfahrung mit Maschinencode und der
Emulation von Prozessoren oblag mir das Seminarthema der
Laufzeitmessung von Altera NIOS CPUs. Dazu wurden verschiedene
Verfahren evaluiert, vom einfachen Profiling bis zum Schreiben eines
kompletten CPU Simulators. Letztendlich sind die Rahmenbedingungen
einer Ausführung im CPLD aber so vielen Faktoren unterworfen dass dies
nicht mit vertretbarem Aufwand und vor allem nicht in der benötigten
Präzision möglich war.  Die einzig verbleibende Option einer
hardwaregestützten Instrumentierung des Codes inklusive Ausführung auf
einem realen CPLD konnte im Rahmen des Projekts leider nicht weiter
verfolgt werden.

Der Kunde verlangte von uns primär eine Windows Applikation, mit der
Option später auf Linux wechseln zu können. Zu diesem Zweck wurde die
Qt Bibliothek von Trolltech als Basis für POA bestimmt. POA an sich
wurde größtenteils unter Linux entwickelt, als einzigem mit Erfahrung
in der der Windows Programmierung im Team oblag es mir die
``Redmond''\footnote{Für die nicht Eingeweihten: Firmensitz der
  Microsoft Corporation} Kompatibiltät des Codes sicherzustellen.
Zuerst wurde dies erreicht mit der Hilfe des MinGW Compilers, einem
GCC Port für Windows. Da aber nur Microsoft Visual C++ offiziell von
Trolltech für Windows unterstützt wird und dieser Compiler auch noch
andere Vorteile mit sich bringt (IDE mit integriertem Debugger,
schnellerer Übersetzer, kompakterer Code), lag es an mir die
Unterschiede der beiden Compiler zu bestimmen und den vorhandenen Code
in einer Art anzupassen, die auf beiden Plattformen lauffähig ist.

Auch im weiteren Verlauf der Entwicklung habe ich neue Codeblöcke und
Code Änderungen evaluiert und gegebenenfalls wieder an Visual C++
angepasst.  Dies umfasste sowohl kleinere Syntaxänderungen als auch
Änderungen an Objektstrukturen (einige Abstürze unter Windows konnte
ich auf Probleme mit der RTTI\footnote{Runtime Type Information}
zurückführen).

Ich habe einen ersten Prototyp des Scheduling Dialog erstellt, den
dann Tammo aus damaligen zeitlichen Engpässen weiterentwickelt hat.

Weiterhin zeichnete ich mich für die Druckfunktionalität sowohl für
die Netzwerke als auch für die Scheduling Übersicht verantwortlich.

Außerdem oblag es mir das manuelle Routen von Verbindungen zu
implementieren.  Nach einigen mehr oder weniger komplizierten
Versuchen habe ich dafür eine im Detail trickreich zu entwickelnde
aber erstaunlich einfach zu bedienende Möglichkeit gefunden, die sich
nahtlos in das vorhandene Konzept eingegliedert hat.

Dafüber hinaus habe ich meine langjährige Erfahrung in der Entwicklung
und nicht zuletzt auch Fehlerbereinigung von Software eingebracht um
im gesamten Projekt kleinere beobachtete Bugs aufzuspüren und gleich
zu beseitigen (``I've got a debugger and I'm not afraid to use it!'').

Last and probably least war ich partiell an der Einführung von
CPPUnit, der Erstellung des Handbuchs sowie des Abschlussberichts
beteiligt.

\subsection{Team}
Das Team hat sich erfreulicherweise als überaus kompetent erwiesen,
eine Eigenschaft die leider auch in höheren Semestern der
Softwaretechnik nicht immer selbstverständlich ist. Auch
Zwischenmenschlich sind mir keinerlei Probleme aufgefallen, im
Gegenteil. Die Team-Grüße war der Aufgabenstellung angemessen.

Das Team war größtenteils sehr motiviert und auch das Projekt
Management hat sehr gut funktioniert. Alles in allem eine sehr
willkommene Abwechslung zu meinem in fast all diesen Punkten etwas
gescheitertem StuPro A.

\subsection{Fazit}
Meine Erachtens war das Projekt ein voller Erfolg, die Vorgaben wurden
laut des Kunden zur vollsten Zufriedenheit erfüllt. Das Arbeitsklima
war durchweg angenehm und der verwendete Software-Prozess war den
leicht ungenauen, aufgrund der weitergehenden Forschung teilweise auch
dem Kunden noch nicht hundertprozentig bekannten Anforderungen
gewachsen.

\section{Steffen Pingel}

\subsection{Aufgaben}

Ich habe vielfältige Aufgaben während des POA Projekts übernommen. In
erster Linie war ich als Projektleiter für das Management des Projekts
und dessen erfolgreichen Abschluss verantwortlich. Ich habe mich
bemüht, im Sinne des Management-By-Objectives, Ziele zu setzen, das
Team zu koordinieren und nur zu führen, wenn es notwendig war. In
diesem Zusammenhang habe ich mich in meinem Seminarvortrag zu dem
Thema ``Extreme Programming'' mit agilen Vorgehensmodellen beschäftigt
und viele Ideen und Konzepte in die Umsetzung des POA Projekts
einfließen lassen.

Das Team war aus sehr unterschiedlichen Mitgliedern zusammen gesetzt.
Mir waren zu Projektbeginn nur zwei Mitglieder persönlich bekannt. Die
Fähigkeiten, Stärken und sehr unterschiedlichen Arbeitsweisen der
anderen Teilnehmer lernte ich erst während des Projekts kennen.
Erschwerend kam hinzu, dass der Erfahrungshorizont innerhalb des Teams
sehr unterschiedlich ausgeprägt war. Vier von den sieben Mitgliedern
hatte zu Beginn des POA Projekts noch kein, wie im Studienplan
eigentlich ausdrücklich gefordert, Studienprojekt begonnen. Wohingegen
die anderen drei zu denen auch ich gehörte bereits ein Studienprojekt
zur Hälfte absolviert hatte. 

Desweiteren erwiess sich die Koordination der individuellen
Wochenpläne als schwierig. Bedingt durch unterschiedlich gewählte
Vorlesungen, andere Studienprojekte, Urlaubsplanung, Krankheit und
Nebenbeschäftigungen war es kaum Möglich einen gemeinsamen Termin zu
finden, der für alle Teilnehmer passend war. Dennoch haben wir sowohl
während der Vorlesungsfreien Zeit als auch während der Vorlesungszeit
Kernarbeitszeiten eingeführt, die die Kommunikation stark erleichtert
haben. 

Die Organisation umfasste sowohl die Vereinbarung von gemeinsamen Team
Terminen als auch die Kommunikation mit den einzelnen Entwicklern. Die
Verteilung der Aufgaben und die Kontrolle der Umsetzung wurde
gemeinsam bei Treffen des Teams vorgenommen. Jeder Entwickler hat zu
Anfang des Treffens ein kurzen Überblick über den Fortschritt seit dem
letzten Treffen gegeben und eine Einschätzung abgegeben wie viel Zeit
bis zur Erfüllung der Aufgabe vorraussichtlich noch benötigt
wurde. Diese persönlichen Zeitschätzungen waren vor allem zu Anfang
des Projekts oft zu optimistisch, wurden aber zunehmend besser, so
dass die Planung zu Ende des Projekts präziser vorgenommen werden
konnte. 

Im Laufe des Projekts habe ich neben der Organisation zahlreiche
produktive Tätigkeiten übernommen. Ich habe mich an der Verfassung des
Angebots beteiligt, sowie den Entwurf mitgestaltet. Während der
einzelnen Iterationen habe ich bemüht meinen Anteil an der Kodierung
möglichst weit einzuschränken. Zum einen stand eine ausreichende Anzahl
von guten Entwicklern im Team zur Verfügung und zum anderen war der
organisatorische Anteil, den ich zum größten Teil erledigt habe, höher
als erwartet. 

Die größte einzelne Komponente die ich entwickelt habe, ist die
Konsistenzprüfung eines Projekts. Dazu war es notwendig mittels
einfachem rekursivem Abstieg die Verbindungen zwischen den Blöcken zu
prüfen und einen Ergebnissbericht zu erzeugen. Desweiteren habe ich
die Settings Klasse implementiert, die globale Einstellungen der
Anwendung verwaltet. Die von mir erstellte Bibliothek zur Speicherung
von vorgefertigten Blöcken macht starken Gebrauch der bereits für die
Projektverwaltung implementierten Serialisierung, so daß ich hier im
wesentlichen die graphische Schnittstelle erstellt habe. 

Maßgeblich habe ich mich um die Umsetzung des Tests bemüht. Das
Interesse der Entwickler an Tests war erwatungsgemäß nicht besonders
hoch. Angesichts des hohen Anteils an schwierig automatisiert
testbaren GUI Quellcodes verständlich. Der Test bestand aus einer
Suite von automatisierten Regression-Tests, die vorwiegend von mir
erstellt wurden. Die Qualität der Tests wurde anhand der
Anweisungsüberdeckung mit dem Werkzeug gcov gemessen.

Die Ausgabe von gcov wurde mit gcover grafisch als HTML Seiten
aufbereitet. GCover ist als Teilprojekt von POA entstanden (siehe auch
\ref{gcover} und orientiert sich an anderen Werkzeugen zur Messung der
Testüberdeckung, von denen allerdings kein kostenloses zur Auswertung
der gcov Asugabe zur Verfügung stand. Ich habe GCover zusammen mit
Tammo van Lessen entwickelt. Tammo van Lessen und ich haben bereits in
anderen Softwareprojekten erfolgreich zusammen gearbeitet und verfügen
beide über eine fundierte Erfahrung mit der Sprache Java. Dadurch
konnten wir GCover in kurzer Zeit fertigstellen ohne unsere
Kernaufgaben innerhalb des POA Projekts zu vernachlässigen.

\subsection{Fazit}

Besonderen Wert habe ich auf die Anwendung, der im
Softwaretechnik-Studium erworbenen Kenntnisse gelegt. Auch auf Grund
von Erfahrungen aus vorherigen einem Studienprojekt war es mir wichtig
den Focus nicht ausschließlich auf den Umfang des Produkts zu legen,
sondern vor allem auch die Qualität und das Vorgehensmodell zu
beachten.

Abschliessend beurteile ich das Projekt als Erfolg. Alle Team
Mitglieder haben sich bemüht das im Studium erworbene Wissen praktisch
umzusetzen. Im Verlaufe des Projekts hat sich eine produktive
Teamdynamik entwickelt, die sich auch in sozialen Aktivitäten
außerhalb der Universität äußert. Das gewählte Vorgehensmodell
erscheint mir den besonderen Anforderungen eines Studienprojekts
gerecht zu werden. Das entstandene Produkt erfüllt die Anforderungen
des Kunden und ist qualitativ gut.

\section{Tammo van Lessen}

\appendix

\chapter{Erklärung gemäß Prüfungsordnung}

Ich erkläre hiermit, daß ich im Rahmen meiner Mitarbeit am
Studienprojekt B ``Programmierumgebung Offener Antrieb'' außer von den
Betreuern vorgesehenen bzw. genehmigten Hilfsmitteln keine unzuläßige
Hilfe in Anspruch genommen habe.

\vspace{2cm}
Stuttgart, den 17. Juni 2004
\vspace{2cm}

\begin{center}
\begin{tabular}{ccc}
  \hspace{5cm} & \hspace{5cm} & \hspace{5cm} \\
  \hhline{-~-} Necati Aydin & & Anselm Garbe \\
  \vspace{2cm} \\
  \hhline{-~-} Stefan Hauser & & Steffen Keul \\
  \vspace{2cm} \\
  \hhline{-~-} Marcel Kilgus & & Steffen Pingel \\
  \vspace{2cm} \\
  \hhline{-~~} Tammo van Lessen \\
\end{tabular}
\end{center}

\end{document}
