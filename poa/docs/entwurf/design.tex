%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Entwurf
%% $Id: design.tex,v 1.9 2004/06/07 09:19:41 keulsn Exp $
%% Achtung: Diese Datei wird in den Entwurf inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Architektur}

\section{Übersicht}

*** Grafik ***

- Was sind Projekte

\section{Entwurfsmuster}

Der Entwurf von POA integriert bekannte und weitverbreitete
Entwurfsmuster, um die Struktur des Entwurfs leicht verständlich zu
machen und für zukünftige Erweiterungen im größtmöglichen Maße offen
zu sein.

Entwufsmuster beschreiben eine Lösungsstrategie für ein abstraktes
Problem. Die Struktur des Codes wird so weitgehend standardisiert und
ermöglicht einem Wartungsingenieur eine schnelle
Einarbeitung. Weiterhin bieten sie Richtlinien an, wie weitere
Funktionalität in das System integriert werden kann.

\subsection{Model-View-Controller}

In dem Model-View-Controller Entwurfsmuster wird die Verarbeitung der
Daten vollständig von der Visualisierung unabhängig gehalten. Die
Daten werden in sogenannten Model Klassen verwaltet und von View
Klassen angezeigt, wobei eine 1:n Beziehung besteht, das heißt mehrere
Views können die selben Daten darstellen. Es werden auch verschiedene
Ansichten auf die selben Daten ermöglicht. Die Kommunikation von
Model- zu View-Klassen erfolgt anonym über Benachrichtigungen (siehe
auch \ref{Benachrichtigungen}).

Eine Model Klasse stellt über get-Methoden oder Iteratoren den Zustand
zur Verfügung. Dieser Zustand wird von einer View-Klasse dem
Anwendungszweck entsprechend angezeigt. Konkret werden die Blöcke,
Pins und Verbindungen in POA jeweils durch Datenobjekte
repräsentiert. Diese werden mit Hilfe von entsprechenden Viewobjekten von der
GridCanvas Klasse angezeigt. 

\subsection{Oberserver}

Die QT Bibliothek erweitert den Sprachumfang von C++ über einen
speziellen Compiler, den Meta-Object-Compiler (MOC), mit einem
Benachrichtigungskonzept. Mit Hilfe von
Benachrichtigungen können Objekte anderen Objekten Mitteilungen über
Zustandsänderungen schicken. Die nahtlose Integration in die
Programmiersprache ermöglicht eine besonders einfache Verwendung des
Mechanismus.

Die Benachrichtigungen (Signals) werden durch das Schlüsselwort emit
gesendet und von speziellen Methoden (Slots) empfangen. Die Signals
und Slots werden in den Klassendeklarationen angegeben. Die Verbindung
zwischen zwei Objekten wird mittels der connect Methode hergestellt. 

In POA wird an mehreren Stellen Gebrauch von dem Signal-Slot
Mechanismus gemacht: 
\begin{enumerate}
\item Wenn sich Einstellungen verändern 
\item Wenn ein Projekt verändert wurde
\item Um die Kommunikation zwischen Pins und den zugehörigen Blöcken
und Konnektoren zu ermöglichen.
\item Um Veränderungen zwischen Models und Views zu synchronisieren.
\end{enumerate}

\subsection{Strategie}

Das Strategiemuster ermöglicht, den Algorithmus für eine Problemlösung
austauschbar zu machen. 

In POA wurde die Routing Schnittstelle für die Verbindungen zwischen
den Blöcken abstrakt definiert und konkret mit zwei verschiedenen
Algorithmen implementiert. Die Algorithmen haben unterschiedliche
Eigenschaften in Bezug auf die Laufzeit und Qualität des Ergebnisses. 

\subsection{Singleton}

Das Singleton Muster wird verwendet, wenn eine Klasse nur genau einmal
instanziert werden soll. Dadurch lassen sich auch in
objekt-orientierten Systemen, äquivalent zu globalen Variablen in
imperativen Systemen, global verfügbare Objekte realisieren,
die über eine definierte Schnittstelle angesprochen werden können. 

In POA ist lediglich die Settings Klasse als Singleton implementiert.

\section{Module}

Die Architektur von POA lässt sich in stark zusammenhängende
Module aufteilen, die eine gerine Kopplung aufweisen. In den folgenden
Abschnitten sind diese Module im Detail beschrieben.

Die Zuordnung von einzelnen Klassen zu Modulen lässt sich in der Regel
aus dem Klassennamen ableiten oder ist aus dem POA
Software-Architektur anhand der Schattierung ersichtlich.

\subsection{Datenmodell (Model)}

In den Model-Klassen wird das Datenmodell eines Projekts
repräsentiert. In POA werden Daten in Objekten der Klassen BlockModel
und PinModel, sowie abgeleiteter Klassen gespeichert. Die Klasse
Projekt stellt den Zusammenhalt zwischen den einzelnen Models her.

\subsection{View}

Views werden verwendet, um dem Benutzer die Daten zu präsentieren. Sie
werden über Signals benachrichtigt, wenn sich ein Model verändert und
passen dann die grafische Darstellung entsprechend an.

\subsection{Controller}

Als Controller wird die Komponente bezeichnet, die Benutzereingaben
und interne Ereignisse verarbeitet und die Synchronisation zwischen
View und Model sicherstellt.

Aktionen, die der Benutzer durch Eingaben anstößt, lösen in QT Signals
aus. Diese Signals werden in POA lokal in dem entsprechenden
View-Objekt verarbeitet, z.B. in CanvasView für alle Aktionen, die auf
dem Canvas geschehen (z.B. Selektieren eines Blocks) oder in
MainWindow (z.B. bei Aktivieren eines Menüpunkts). Aufwändige
Bearbeitungen werden in spezielle Action-Objekte ausgelagert.

Eine Besondere Auslagerung der Controller bietet sich für POA nicht
an. Die Benutzer-Eingaben erfolgen auf einer bestimmten View und das
zugehörige View-Objekt hat die nötigen Kompetenzen, um die Eingabe zu
verarbeiten. Falls eine Bearbeitung mehrere Schritte erfordert, so
erzeugt das View-Objekt ein Action-Objekt, um die Aufgabe zu
erledigen.

\subsection{Scheduling}

Optimales Scheduling bedeutet in POA die Berechnung eines optimalen
Offsets für jeden Block, da die Taktraten für jeden Block bereits
feststehen.

Die optimalen Offsets werden in POA für bestimmte Signalpfade
berechnet. Hierzu dient dienen Objekte der Klasse Path. Für jeden
gewünschten Signallaufpfad wird ein solches Objekt erzeugt. Dann kann
die Signallaufzeit minimiert werden, indem alle Path-Objekte in einer
definierten Reihenfolge einzeln optimiert werden.

Die Path-Objekte verwenden dazu eine Graph-Struktur, die von der
Klasse Blockgraph angeboten wird. Ein BlockGraph besteht aus einer
Reihe von BlockNode-Objekten. In den BlockNode-Objekten kann ein Flag
gesetzt werden. Anhand dieses Flags erkennt der
Optimierungsalgorithmus, ob ein bestimmter Knoten bereits einen
optimalen Offset erhalten hat, oder noch verändert werden darf.

Eine Auswahl von Signallaufpfaden, kann der Benutzer in dem
AutoSchedulingDialog vornehmen. Dieser Dialog bedient sich des
BlockGraphs, um eine Liste aller Blöcke anzuzeigen, die noch in keinem
Pfad enthalten sind.

\subsection{Download}

Der Download ist in der Klasse DownloadManager implementiert. Zur
Übertragung der Daten wird die QExtSerialPort Bibliothek verwendet.
Die Bibliothek einheitliche Methoden zum Zugriff auf die serielle
Schnittstelle für Windows und Linux. Die Initialisierung erfolgt in
der initializeAndOpen() Methode. Hier können die fest programmierten
Übertragungsparameter und die Geschwindigkeit geändert werden. Die
Übertragung der Daten erfolgt in der download() Methode und kann hier
angepasst werden, falls sich das Übertragungsprotokoll ändert.
 
\subsection{Routing}

Die Routing Schnittstelle ist sehr abstrakt definiert. Es wird
lediglich die Verbindung zweier Punkte auf einem GridCanvas gefordert.
Zwei Routing Algorithmen mit sehr unterschiedlichen Eigenschaften
implementieren diese Schnittstelle.

Der DirectRouter stellt die Verbindung anhand von Fallunterscheidungen
mit der geringsten Anzahl von Knickpunkten her ohne Überschneidungen
zu berücksichtigen. Der Algorithmus ist ausreichend schnell, um die
Verbindungen während des Verschiebens von Blöcken simultan
neuzuberechnen. 

Der Dijkstrarouter benutzt den Dijkstra Algorithmus um eine optimale
Route mit möglichst wenig Knickpunkten und Überschneidungen zu finden.
Auf Grund der Vielzahl der möglichen Wege beträgt die Laufzeit des
Algorithmus in der Regel ein vielfaches des DirectRouter.

Durch Ableitung der ConnectorRouter Klasse und Erweiterung der
GridCanvas Klasse ist jederzeit eine Implementierung von zusätzlichen
Routing Algorithmen möglich. 

\subsection{Problemreport}

Die Klasse ProblemReportManager validiert ein Projekt und stellt eine
Baumansicht mit den Ergebnissen zur Verfügung. Im ersten Schritt
werden alle Blöcke sequentiell geprüft. Im zweiten Schritt werden die
Verbindungen zwischen den Blöcken geprüft. Die Validierung erfolgt in
der report() Methode und checkBlock() Methode. Hier können weitere
Prüfungen eingefügt werden. Für jeden Fehler wird ein Objekt vom Typ
ProblemReportItem erzeugt.

\subsection{Querschnittsmodule}

Einige Klassen können keinem Modul zugeordnet werden, da diese von
vielen Modulen benutzt werden. Einige dieser Querschnittsklassen sind
im folgenden beschrieben.

\subsubsection{Einstellungen (Settings)}

In den Settings werden globale Einstellungen wie Farben, Schriftarten
und Pfade verwaltet, die zum Teil auch über den Einstellungsdialog vom
Benutzer geändert werden können. Änderungen von Einstellungen, die
direkt in der Anwendung sichtbar gemacht werden sollen, werden über
entsprechende Signale bekannt gemacht.

\section{Persistenz}

\subsection{XML Format}




%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
