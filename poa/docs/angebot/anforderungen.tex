%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Anforderungen
%% $Id: anforderungen.tex,v 1.7 2003/06/12 11:35:47 papier Exp $
%% Achtung: Diese Datei wird ins Angebot inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Anforderungen
\chapter{Anforderungen}
Dieses Kapitel beschreibt die Anforderungen des Kunden an das
Studienprojekt B, ''Programmierumgebung Offener Antrieb'' (POA).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hintergrund
\section{Hintergrund}
Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen gemacht.
Viele dieser Entwicklungen beinhalten neue Kinematiken, wie z.B. die
Parallelkinematiken und Sensoren (z.B. den Ferraris 
Relativbeschleunigungssensor).\par
Dadurch entstehen neue Anforderungen an die Antriebsregelung. Zusätzliche
Sensor-Signale müssen in den Reglerstrukturen berücksichtigt werden -- oder
es werden sogar völlig neue Reglerstrukturen benötigt.\par
Die momentan auf dem Markt erhältlichen Reglersysteme erlauben meist
weder die Berücksichtigung neuartiger Sensoren, noch bieten sie die
Möglichkeit, eigene anwenderspezifische Reglerstrukturen zu implementieren.\par
Daher wird am ISW eine Plattform für die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene Funktionalitäten
zu integrieren. Diese Plattform wird am ISW kurz als ``Offener Antrieb''
bezeichnet.  \par
Die hardwaretechnische Realisierung erfolgt in Form einer PC-Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX''Baustein. Es
handelt sich dabei um einen CPLD\footnote{Complex Programmable Logic Device},
der sich frei programmieren lässt. Der Anwender hat die Möglichkeit, die
Funktion des Bausteins seinen Bedürfnissen anzupassen.\par
Um die Offenheit für jeden Anwender nutzbar zu machen, wird für den CPLD eine
Architektur festgelegt, die es ermöglicht, einzelne Funktionalitäten in Form
von Modulen zu implementieren. Diese Module können aus festprogrammierten
Schaltungen (Cores) und freiprogrammierbaren CPUs bestehen. Jedes Modul kann
auf die Signale aller anderen Module zugreifen und stellt seine eigenen
Ausgangssignale allen anderen Modulen zur Verfügung.\par
Inhalt dieses Angebotes ist es, eine Programmierumgebung für das Netzwerk
von CPUs und Cores zu schaffen, in dem ein bereits auf dem CPLD vorhandenes
Netzwerk konfiguriert werden kann.\par
Die detaillierten Anforderungen der hiermit angebotenen ``Programmierumgebung
Offener Antrieb'' erschliessen sich nur aus dem Zusammenhang des im Folgenden
dargelegten Kataloges der Funktionalen Anforderungen. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionale Anforderungen
\section{Funktionale Anforderungen}

Die ``Programmierumgebung Offener Antrieb'' soll eine englisch-sprachige,
grafische Oberfläche mit folgenden wesentliche Funktionalitäten bieten:
\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Editierung einer CPLD-Modulbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung für eingebette CPU-Module in einem CPLD-Layout
\item Plausibilitätsprüfung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen eines fertiggestellten CPLD Layouts
\item Speichern und Öffnen von CPLD-Layouts und zugehörigen Sourcen
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}
Auf die Einzelheiten der wesentlichen Funktionalitäten und der Abgrenzung der
aufgeworfenen Begriffe wird in den folgenden Abschnitten eingegangen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD Layouts
\subsection{CPLD Layouts}
Ein CPLD Layout spiegelt ein virtuelles Abbild der realen Konfiguration
(Vernetzung der CPLD-Funktionsblöcke) eines CPLD Hardware-Bausteins wider.
Dabei besteht die virtuelle Abbildung aus Funktionsblöcken (CPUs, Cores,
E/A-Blöcke) und Signalleitungen.\par
Im zu entwickelnden System soll ein CPLD Layout rasterisiert dargestellt
werden und durch Maus- und Tastatureingaben manipulierbar sein. Dabei
werden Funktionsblöcke mit der Maus in ein Raster eingebettet und durch
einzelne Linien, die die Signalleitungen symbolisieren, verbunden.
Die Funktionsblöcke selbst sollen konfigurierbar und editierbar sein.\par
CPLD-Layouts sollen XML-basiert speicher- und ladbar sein. Sie werden
zusammen mit dem zugehörigen Source- und evtl. vorhandenen Object-Code
in einer geeigneten Verzeichnisstruktur abgelegt.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD-Modulbibliothek
\subsection{CPLD-Modulbibliothek}
Die Modulbibliothek ist eine CPLD-Layout übergreifende Sammlung von
Funktionsblöcken (CPU, Cores, E/A-Blöcke), die in CPLD-Layouts einbettbar
sein sollen. Die Funktionsblöcke sollen in einer XML-Struktur verwaltet
werden.\par
Als Initialbefüllung werden verschiedene Core-Blöcke, ein E/A-Block und
ein CPU-Block angeboten. Die Modulbibliothek ist nur durch Editierung der
zugrundeliegenden XML-Struktur veränderbar.\par
Die Modulbibliothek soll bei jedem Systemaufruf automatisch geladen werden.
Eine Verwaltung verschiedener Modulbibliotheken wird nicht angeboten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionsblock
\subsection{Funktionsblock}
Ein Funktionsblock spiegelt ein virtuelles Abbild eines CPU-, Core- oder
E/A-Bausteins auf einem CPLD wider. Dabei sollen an allen genannten
Funktionsblöcken die Ein- und Ausgänge mit Signalleitungen verbunden
werden können.\par
Speziell bei CPU-Blöcken soll überdies die Anzahl der Ein- und Ausgänge,
die Benennung der E/As, das Einstellen eines Zeitoffsets, das Setzen
einer logischen Taktrate konfigurierbar sein und der auf dem jeweiligen
CPU-Block auszuführende Sourcecode editierbar sein.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Rahmencodegenerierung
\subsection{Rahmencodegenerierung}
Zur Editierung von C-Sourcen für CPU-Blöcke soll ein (vom Kunden)
vordefiniertes C-Template kontextabhängig für die existierende
Konfiguration eines CPU-Blocks verwendet werden, um Rahmencode zu generieren.
Dabei soll die Benamung der Signal-Ein- und Signal-Ausgänge im C-Sourcecode
eines einzelnen CPU-Blocks angepaßt werden. Hierzu wird lediglich ein
einfacher Substitutionsalgorithmus ohne tierfergehende Logik angeboten.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plausibilitätsprüfung
\subsection{Plausibilitätsprüfung}
Die Vernetzung von Funktionsblöcken in einem entworfenen CPLD-Layout soll
auf ihre Plausibilität geprüft werden können, im Einzelnen:
\begin{itemize}
\item Prüfung auf unverknüpfte E/As
\item Prüfung auf falsch verknüpfte E/As (E-E, etc.)
\end{itemize}
Sofern das entworfene CPLD-Layout Ungereimtheiten aufweist, soll eine
Warnmeldung ausgegeben werden, die die fehlerhaften Verknüpfungen aufführt.\par


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Optimierung
\subsection{Optimierung}
Der Entwurf eines plausiblen CPLD-Layouts soll durch einen gekoppelten
Signallaufzeitsermittlungs- und -optimierungs-Algorithmus optimiert werden
können. Hierzu wird zur Laufzeitermittlung ein Laufzeitermittlungsprogramm
für CPLD-CPU-Block Object-Code verwendet, das vom Kunden zu liefern ist.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Compilieren und Herunterladen
\subsection{Compilieren und Herunterladen}
Einzelne Funktionsblöcke eines plausiblen CPLD-Layouts und gesamte plausible
CPLD-Layouts sollen durch einen externen Compiler compiliert werden können,
der vom Kunden zu liefern ist.\par
Weiterhin soll ein plausibles und vollständig compiliertes CPLD-Layout auf
den CPLD heruntergeladen werden können. Um diese Anforderung umsetzen zu 
können, hat der Kunde die Schnittstelle sowie ein Beispielprogramm zu liefern.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Externe Programme
\subsection{Externe Programme}
Zur Editierung von Sourcecode, zum Compilieren von Sourcecode, zum
Herunterladen von Object-Code und zur Laufzeitbestimmung sollen externe
Programme eingesetzt werden.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Konfiguration
\subsection{Konfiguration}
Es soll der externe Editor, der externe Compiler der Pfad zum C-Souce
Template und das externe Download-Tool konfigurierbar sein.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionale Anforderungen
\section{Nicht funktionale Anforderungen}
Die Implementierung der Software erfolgt in C++ auf der Basis von
Trolltech QT 3.0.1. Als Zielplatform wird Redhat GNU/Linux 8.2
festgelegt.

\subsection{Hardware}
Die minimalen Hardware Anforderungen entsprechen denen der Zielplattform.

\subsection{Mengengerüst}
\begin{itemize}
\item Eine CPLD hat maximal 20 Cores und 10 CPUs.
\item Die Modulbibliotek enthält maximal 100 Module.
\item Ein Funktionsblock hat zu max.XXX Bussen zusammengefasste Ein-
  und Ausgänge.
\end{itemize}

\subsection{Wartbarkeit}
Die Wartbarkeit des Quellcodes wird durch eine verbindliche
Codierrichtline und Kommentierung sichergestellt.

%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
