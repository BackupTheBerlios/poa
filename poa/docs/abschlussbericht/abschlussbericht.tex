%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Abschlussbericht
%% $Id: abschlussbericht.tex,v 1.33 2004/06/16 02:17:54 keulsn Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,titlepage,12pt,ngerman]{scrbook}
\usepackage{../common/header}
\RequirePackage{hhline}

\RCSdef $Revision: 1.33 $
\RCSdef $Date: 2004/06/16 02:17:54 $

\newcommand\version{Version 1.0 \xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Deckblatt

\begin{titlepage}
\input{../common/logo}
\Huge Abschlussbericht

\setcounter{footnote}{0}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Versionsgeschichte

\section*{Versionsgeschichte}

\begin{itemize}

\item Version 1.0 (17.06.2004)

  Diese Version wurde dem Auftraggeber vorgelegt.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}

\section{Zweck des Dokuments}

Dieses Dokument beschreibt das Projekt ``Programmierumbgebung Offener
Antrieb'' (POA), das von Anfang Mai 2003 bis Ende April 2004 an der
Universität Stuttgart am Institut für Steuerungstechnik der
Werkzeugmaschinen und Fertigungseinrichtungen (ISW) durchgeführt
wurde. Das Projekt wurde von sieben Softwaretechnik Studenten - Necati
Aydin, Anselm Garbe, Stefan Hauser, Steffen Keul, Marcel Kilgus,
Steffen Pingel und Tammo van Lessen - im Rahmen eines Studienprojekts B
durchgeführt. Im Folgenden wird ein Überblick über die erzielten
Ergebnisse, den Projektverlauf und die persönlichen Eindrücke der
Teilnehmer gegeben.
 
\section{Hintergrund des Projekts}

Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen
gemacht. Diese Entwicklungen beinhalten neue Kinematiken, wie z.B. die
Parallelkinematiken und Sensoren (z.B. den Ferraris
Relativbeschleunigungssensor). Dadurch entstehen neue Anforderungen an
die Antriebsregelung. Zus"atzliche Sensor-Signale m"ussen in den
Reglerstrukturen ber"ucksichtigt werden -- oder es werden sogar
v"ollig neue Reglerstrukturen ben"otigt.

Die momentan auf dem Markt erh"altlichen Reglersysteme erlauben meist
weder die Ber"ucksichtigung neuartiger Sensoren, noch bieten sie die
M"oglichkeit, eigene anwenderspezifische Reglerstrukturen zu
implementieren.

Daher wird am ISW eine Plattform f"ur die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene
Funktionalit"aten zu integrieren. Diese Plattform wird am ISW an der
Universit"at Stuttgart kurz als ``Offener Antrieb'' bezeichnet.

Die hardwaretechnische Realisierung erfolgt in Form einer Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX'' Baustein. Es
handelt sich dabei um ein CPLD\footnote{Complex Programmable Logic Device},
das sich frei programmieren l"asst. Der Anwender hat die M"oglichkeit, die
Funktion des Bausteins seinen Bed"urfnissen anzupassen.

Um die Offenheit f"ur jeden Anwender nutzbar zu machen, wird f"ur das CPLD eine
Architektur festgelegt, die es erm"oglicht, einzelne Funktionalit"aten in Form
von Bl"ocken zu implementieren. Diese Bl"ocke k"onnen aus festprogrammierten
Schaltungen (Cores) oder freiprogrammierbaren CPUs bestehen. Die
Signale können über ein freiprogrammierbares Netzwerk verbunden
werden. 

Diese komplexe Netzwerke auf einer von der Hardware abstrahierten
Ebene für den Anwender einfach programmierbar zu machen ist die
Kernanforderung des POA-Projekts. 

\section{Anforderungen}

Aus dem im vorherigen Abschnitt skizzierten Projekthintergrund ergaben
sich folgende Anforderungen im Detail, deren Umsetzung in einem
Angebotsdokument verbindlich mit dem Auftraggeber vereinbart wurden:

\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Bearbeitung einer CPLD-Blockbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung f"ur eingebettete CPU-Bl"ocke in einem CPLD-Layout
\item Plausibilit"atspr"ufung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen von Quellcode f"ur die CPU-Bl"ocke
\item Speichern und "Offnen von CPLD-Layouts und zugeh"origem Quellcode
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}

Diese Anforderungen wurden im Laufe des Projekts vollständig
implementiert. Darüberhinaus wurden folgende zusätzliche Anforderungen
umgesetzt: 

\begin{itemize}
\item Automatisches Routing von Verbindungen zwischen Blöcken
\item Drucken von Netzwerken
\item Vergrößern und verkleinern der Netzwerkansicht
\item Automatische Laufzeitoptimierung von Signalen (Scheduling)
\item Öffnen mehrerer Projekte zur gleichen Zeit mit
  Datenaustauschmöglichkeiten über die Zwischenablage
\item Anzeige der Taktfrequenzen mittels Einfärbung der Blöcke
\item Lokalisierung in Deutsch und Englisch
\item Lauffähigkeit unter Microsoft Windows und Linux
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektergebnisse}

\section{Programmierumgebung Offener Antrieb}

Aus den genannten Anforderungen resultierte die ``Programmierumgebung
Offener Antrieb'', kurz POA. POA ist eine Applikation mit graphischer
Oberfl"ache basierend auf der Qt-Bibliothek von Trolltech. Die
Bedienung erfolgt intuitiv per Drag-and-Drop. Aus der Bibliothek auf
der linken Seite können Blöcke auf die Arbeitsoberfläche gezogen
werden und in einem Dialog konfiguriert werden.

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{poa}
  \caption{Hauptfenster}
\end{figure}

Einstellbar sind Parameter wie die Taktrate, Laufzeit und die Anzahl
der Pins, über die andere Blöcke vernetzt werden können. CPUs bieten
außerdem die Möglichkeit, über den Aufruf eines externen Editors,
Quellcode zu hinterlegen, der auf der CPU ausgeführt wird, nachdem der
Download auf den CPLD erfolgt ist. Damit können vollständig selbst
entwickelte Regelungsalgorithmen verwendet werden. Wenn mehrere Blöcke
auf der Arbeitsoberfläche plaziert wurden, können diese mit der Maus
an ihren Pins verbunden werden.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{blockconfiguration}
  \caption{Block Konfigurationsdialog}
\end{figure}

Sobald ein Projekt fertig gestellt ist, kann die Laufzeit eines oder
mehrerer Signale nach einer priorisierten Liste optimiert werden. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{scheduling}
  \caption{Scheduling Dialog}
\end{figure}

Ein Signal entspricht der Berechnung eines Ausgangswertes aus einem
Eingangswert. Eingangswerte werden durch Eingangsblöcke repräsentiert
und der Signalweg durch die Verbindung von Blöcken zu einem
Ausgangsblock festgelegt. Durch Berechnung eines optimalen Offsets für
die Taktung eines Blocks kann nun erreicht werden, dass ein bestimmtes
Signal in kürzest möglicher Zeit das Netzwerk durchläuft.

Nach der Optimierung der Signallaufzeiten kann das Projekt auf
Konsistenz geprüft werden. In einem Dialog wird in einer Baumansicht
eine Liste mit möglichen Problemen, wie beispielsweise nicht verbundene
Blöcke, mit einer detailierten Beschreibung angezeigt. Je nach Art des
Problems kann über eine Schaltfläche ein Lösungsvorschlag angewendet 
werden.

Ein erfolgreich geprüftes Projekt kann anschliessend auf einen CPLD
übertragen werden. Bisher ist nur der Download des kompilierten
Quellcodes einer einzelnen CPU möglich, da hardwareseitig bisher keine
Unterstützung für mehrere CPUs vorgesehen ist.

Diese Kurzbeschreibung soll einen Eindruck der Funktionalität bieten.
Eine vollständige Beschreibung der Benutzungsoberfläche von POA kann
dem Handbuch entnommen werden.

\subsection{Technische Umsetzung}
\label{design}

Die Architektur von POA wurde aufgrund des forschungsnahen Charakters
des Projekts mit den Zielen einfacher Erweiterbarkeit und hoher
Änderbarkeit entworfen. Erreicht wurden diese Eigenschaften in erster
Linie durch ein einfaches Design. Es wurden nur die notwendigen
Klassen implementiert und keine Technologie auf Vorrat angelegt.
Soweit möglich wurden Entwurfsmuster verwendet, um das einfache
Verständnis des Quellcodes zu erhöhen. Es wurden unter anderen das
Model-View-Controller-, Strategie- und das Singletonmuster benutzt.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{design}
  \caption{POA Architektur}\label{arch_grafik}
\end{figure}

Die Architektur von POA gliedert sich in stark zusammenhängende
Module, die durch schmale Schnittstellen miteinander kommunizieren und
so eine geringe Kopplung aufweisen. So kann jedes dieser Module
einzeln an geänderte Anforderungen angepasst werden, wobei die
Interoperabilität erhalten bleibt. Auf diese Weise wird die
größtmögliche Flexibilität für die Weiterentwicklung und Wartung der
Software sichergestellt.

In Abbildung \ref{arch_grafik} werden die Module von POA dargestellt.
Die grün dargestellten Module bilden die Basis des POA-Systems.
Entwürfe für Regler auf dem Offenen Antrieb werden in Projekten
entwickelt. Die Daten eines Projekts werden in den Models des Projekts
gespeichert.

Die rot dargestellten Module, Problemmanager, Scheduling und Download,
bilden die wesent\-lichen Aufgaben von POA ab.

\begin{itemize}
\item Prüfen der Integrität eines Projekts und Anzeige der
  aufgefundenen Probleme
\item Automatische Berechnung eines optimalen Schedulings für das
  Netzwerk von Blöcken
\item Compilation des Quellcodes und Download auf die spezifizierten
  CPUs
\end{itemize}

Die in blau eingefärbten Module realisieren die
Benutzungsschnittstelle von POA. Das Modul GUI umfasst Klassen zur
Darstellung von Dialogen. Die Views visualisieren die relevanten
Nutzdaten und das Routing-Modul wird eingesetzt, um Konnektoren
überkreuzungs\-arm in ein Netzwerk einzubringen.

Schließlich bietet das Utils Modul diverse Funktionalität, die häuftig
benötigt wird. Die Klassen dieses Moduls sind Kandidaten um in
folgenden Projekten wiederverwendet zu werden.

Eine detailierte Beschreibung der Architektur befindet sich im
Entwurfsdokument.

\section{Dokumente}

Neben der Programmierumgebung ist im Laufe des Projekts Dokumentation
entstanden.

\subsubsection{Angebot}
\label{angebot}

In einem knapp 20-seitigen Angebot wurden die Anforderungen und ein
Projektablaufplan mit dem Auftraggeber vereinbart. Das Angebot
beinhaltete desweiteren eine Risikoanalyse und eine Beschreibung des
Prozessmodells und der geplanten Projektorganisation. In einem
angehängten Begriffslexikon wurden Begriffe der Problemdomäne
definiert, die zur Kommunikation mit dem Auftraggeber und innerhalb
des Teams verwendet wurden.

\subsubsection{Entwurf}

Ein Entwurf entstand zuerst in Form von Quellcode-Dateien, die
Klassendeklarationen ohne Programmlogik enthielten. Zum Ende des
Projekts wurde die Architektur der letzten ausgelieferten Version in
Form eines Dokuments beschrieben. Dieses Dokument enthält eine
detailierte Beschreibung der POA-Architektur. Es soll bei einer
möglichen Weiterentwicklung der Software als Orientierungshilfe
dienen. Das Entwurfsdokument wird durch ein A0 Poster, das die
gesammte Klassenstruktur als UML-Diagramm zeigt, ergänzt.

\subsubsection{Handbuch}
\label{handbuch}

Dem Benutzer steht ein 40-seitiges mit Bildschirmfotos illustriertes
Handbuch zur Verfügung. Das Handbuch enthält einen Referenzteil, der
die Programmdialoge beschreibt und ein Tutorial, das dem
unerfahrenen Benutzer anhand eines Beispiels einen leichten Einstieg
in die Bedienung von POA ermöglicht.

\subsubsection{Interne Dokumente}

Einige Dokumente wurden nur innerhalb des Teams verwendet und nicht an
den Auftraggeber ausgeliefert. Zu nennen sind hier eine Spezifikation,
die in Form von Benutzungsfällen den Funktionsumfang der ersten
Version beschreibt, Kodierungsrichtlinien im Rahmen des
Konfigurationsmanagements und der Testbericht des Systemtests.

\section{Weitere Ergenisse}
\label{gcover}

\subsection{GCover}

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{gcover}
  \caption{HTML-Ausgabe von GCover}
\end{figure}

Im Rahmen des POA-Projekts entstand als Nebenprodukt eine Software zur
Auswertung der, von dem Werkzeug gcov, ermittelten Testüberdeckung.
Gcov ist Teil der GNU gcc Compilersuite, die zur Übersetzung von POA
verwendet wurde. Gcov annotiert im Wesentlichen die einzelnen
Quellcodezeilen mit einer Zahl, die angibt wie oft die jeweilige Zeile
ausgeführt wurde. Zusätzlich wird auf der Konsole für jede Quellcode
Datei ausgegeben wie hoch die Zweigüberdeckung ist. Die Auswertung der
gcov Ausgabe ist umständlich und wird deswegen von Entwicklern oft
gemieden.

Um die Ergebnisse anschaulich und einfach verfügbar zu machen, wurde
GCover entwickelt. GCover wertet die Ausgabe von gcov aus und stellt
die Anweisungsüberdeckung in einem HTML Frameset ähnlich dem
verbreiteten JavaDoc von Sun dar.

GCover generiert eine Übersichtsseite, die die Anweisungs- und
Zweigüberdeckung aller Dateien anzeigt. Bei Auswahl einer Datei wird
der Quellcode der Datei angezeigt. Die Zahl in der linken Spalte gibt
die Zeilennummer und die Anzahl der Ausführungen der jeweiligen Zeile
an. Nicht überdeckte Zeilen werden rot unterlegt.

GCover wurde im POA-Projekt eingesetzt, um die Vollständigkeit des mit
CppUnit durchgeführten Regressionstests zu überprüfen. Es diente den
Entwicklern als Hilfsmittel um nicht ausgeführte Zeilen zu finden und
die Tests entsprechend anzupassen.

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{gcover-file}
  \caption{Anweisungsüberdeckung einer einzelnen Datei}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektorganisation}

\section{Projektrahmen}

Der Auftrag zur Entwicklung von POA wurde von Dipl.-Ing. Christian
Kramer vergeben. Er war als Kunde für die Formulierung der
Anforderungen und Abnahme der Ergebnisse zuständig. Christian Kramer
war auch bei fachlichen Fragen immer für das Team erreichbar und 
stets bereit auch kurzfristige Terminvereinbarungen einzugehen. Als
Betreuer stand Dipl.-Ing. Peter Pruschek zur Verfügung.

\section{Das Team}

Der Auftragnehmer bestand aus einem Entwicklerteam von sieben
Studenten der Softwaretechnik, die zu Beginn des Projekts im sechsten
Semester studierten. Auf dem Bild \ref{poa-stuttgart} zusehen sind
Necati Aydin, Marcel Kilgus, Tammo van Lessen, Anselm Garbe, Stefan
Hauser und Steffen Pingel (von links). Steffen Keul hielt sich zum
Zeitpunkt der Aufnahme bereits auf Grund eines Praktikums im Ausland
auf. Er ist auf dem zweiten Gruppenbild \ref{poa-portland} zu finden.

\begin{figure}[h!]
  \centering
  \begin{center}
    \includegraphics[width=10cm]{Fotos/group_3}
  \end{center}
  \caption{POA-Team Stuttgart}\label{poa-stuttgart}
\end{figure}

\begin{figure}[h!]
  \centering
  \begin{center}
    \includegraphics[width=10cm]{Fotos/group_portland}
  \end{center}
  \caption{POA-Team Portland, OR.}\label{poa-portland}
\end{figure}

\subsection{Rollen}

Auf die Vergabe von formalen Rollen wurden mangels Notwendigkeit
weitgehend verzichtet. Die Zuteilung der Aufgaben erfolgte
gemeinschaftlich soweit möglich auf Basis freiwilliger Übernahme
während gemeinsamer Team-Treffen. Wenn eine Aufgabe von keinem der
Entwickler übernommen wurde, wurde diese vom Projektleiter zugeteilt.

Auch die Rolle der Qualitätssicherung wurde nicht explizit vergeben.
Die Qualitätssicherung wurde im Sinne des kooperativen Vorgehensmodell
als gemeinschaftliche Aufgabe aufgefasst. Die Dokumente wurden in der
Regel von mindesten zwei Entwicklern gemeinsam verfasst und
grundsätzlich anschliessend von dem gesamten Team in einem Review
geprüft. Die Qualität des Quellcodes wurde in Form von Peer-Reviews
laufend geprüft. Die einzelnen Quellcode-Dateien konnten von jedem
Entwickler eingesehen und geändert werden (siehe auch \ref{developer
  by file}).

\subsubsection{Projektleiter}

Der Projektleiter war für den Kontakt mit dem Kunden und für die
Koordination des Teams zuständig. Im Sinne der Organisation von
Reviews hat der Projektleiter teilweise die Aufgaben der
Qualitätssicherung übernommen. Die Rolle des Projektleiters wurde von
Steffen Pingel übernommen.

\subsubsection{Konfigurationsmanager}

Der Konfigurationsmanager war für die Verwaltung des zentralen
Repositories, in dem sowohl die Dokumente als auch der Quellcode
gespeichert wurde, zuständig. Desweiteren wurden vom
Konfigurationsmanager Richtlinien zur Formatierung des Quellcodes und
zur Benutzung des Repositories erstellt. Die Rolle des
Konfigurationsmanagers wurde von Anselm Garbe übernommen.

\subsubsection{Entwickler}

Die Aufgabe der Entwickler war die Erstellung des Quellcodes und das
Verfassen der Dokumente. Die Rolle der Entwickler wurde von allen
Teilnehmern belegt.

\section{Entwicklungsphilosophie}

Die flache und demokratische Organisationsstruktur des Projekts
spiegelt die kooperativen Entwicklungsphilosophie wieder. Auch
gegenüber dem Auftraggeber waren Transparenz und Kooperation die
zentralen Anliegen des Teams. Über die Internetseite des Projekts war
während der Implementierungsphase über den Tracker (siehe auch
\ref{jira}) und das Quellcode Repository (siehe auch \ref{berlios})
jederzeit Einblick in den aktuellen Fortschritt sowohl für die
Entwickler als auch für den Auftraggeber möglich.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektablauf}

\section{Prozessmodell}

Als Prozessmodell wurde ein Inkrementell-Iteratives
Prozessmodell\footnote{siehe Balzert, Helmut: Lehrbuch der
  Software-Technik, Band 2, Spektrum, 1998} gewählt, wobei nicht alle
Phasen in den einzelnen Iterationen ausgeführt wurden. Die
Spezifikationsphase wurde nur zu Beginn des Projekts einmalig
durchlaufen. Auch ein Systemtest wurde nur zum Ende des Projekts
ausgeführt.

Die einzelnen Iterationen, im Angebotsdokument noch als Sprints
bezeichnet, bestanden jeweils aus einer Anforderungsanalyse-,
Entwurfs- und Kodierungsphase, die von einem kontinuierlichen
Regressionstest begleitet wurde. Zu Ende jeder Iteration wurde das
weiter entwickelte Produkt ausgeliefert und vom Kunden einem
Akzeptanztest unterzogen.

Das Prozessmodell wurde gewählt um dem Forschungscharakter des
Projekts gerecht zu werden. Zu Beginn des Projekts war unklar wie stark
sich die Anforderungen während des Projekts ändern würden. Deswegen
wurde zu Anfang jeder Iteration eine erneute Anforderungsanalyse mit
dem Auftraggeber durchgeführt und eine Rückmeldung über das Ergebnis
der vorherigen Iteration eingeholt.

Im Nachhinein lässt sich feststellen, dass die Anforderungen im Laufe
des Projekts nur geringfügig von den zu Anfang des Projekts
ermittelten abgewichen sind. Dennoch erwies sich der zusätzliche
Aufwand mehrerer Iterationen im Vergleich zu einer einzigen, wie es
das klassische Phasenmodell vorsieht, als sinnvoll. Es war dem
Auftraggeber möglich eine priorisierte Liste der Anforderungen zu
formulieren, so dass die wichtigsten Anforderungen zuerst umgesetzt
werden konnten. Da am Ende jeder Iteration eine lauffähige Version
ausgeliefert wurde hätte im Falle eines Scheiterns des Projekts ein
Ergebnis mit dem zum jeweiligen Zeitpunkt maximalen
Funktionsumfang zur Verfügung gestanden.

Erfreulicherweise ist keines der im Angebot aufgeführten Risiken, die
zu einem Projektabbruch führen konnten, eingetreten. 

\section{Projektplan}

Der ursprünglich im Angebot vorgesehene Zeitplan diente als grobe
Orientierung für den Projektverlauf. Die Planung und Ausführung war im
Wesentlichen von einer Hausmesse Mitte Oktober am ISW und dem Ablauf
der Semesters geprägt.

\begin{figure}[h!]
  \centering
  \begin{tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Termin} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 200 & KW 25 & M1: Angebot \\
     2 & Spezifikation & 300 & & \\
     3 & Entwurf & 300 & & \\
     4 & Prototyp Messe & 300 & 01.10.2003 & M2: Prototyp Messe \\
     5 & Prototyp Erweitert & 300 & 10.11.2003 & M3: Prototyp Erweitert \\
     6 & Sprint 1 & & KW 48 - 51 & \\
     7 & Sprint 2 & & KW 2 - 6 & \\
     8 & Sprint 3 & & KW 8 - 12 & \\
     9 & Auslieferung und Präsentation & & 01.04.2004 & M4: Auslieferung\\
    \hline
       & & 1400\\
  \end{tabular}
  \caption{Ursprünglicher Zeitplan aus dem Angebot}
\end{figure}

Die ursprünglich geplanten zwei Prototyp Entwicklungsphasen und drei
Sprints wurden auf drei, im Folgenden als Iterationen bezeichnete,
Phasen reduziert. Zum einen stellte sich während des Projekts heraus,
dass die Anforderungen abgesehen von kleinen zusätzlichen funktionalen
Anforderungen weitgehend stabil waren. Zum anderen war der zeitliche
Aufwand, bedingt durch organisatorische Tätigkeiten wie eine
Produktpräsentation am Ende jeder Iteration, höher als erwartet.

Die vereinbarten Meilensteine wurde eingehalten bzw. mit
Einverständnis des Kunden geringfügig verschoben. Durch eine
kontinuierliche Fortschrittskontrolle und Planungsanpassung wurde vom
Team dazu beigetragen die Wahrscheinlichkeit einer Verzögerung
frühzeitig erkennbar zu machen. Auf Grund der Reduzierung der
Iterationen wurde der Meilenstein M3 gestrichen.

Als schwierig erwies sich die Koordination der individuellen
Wochenpläne. Bedingt durch unterschiedlich gewählte Vorlesungen,
andere Studienprojekte, Urlaubsplanung, Krankheit und
Nebenbeschäftigungen war es kaum möglich gemeinsame Termine zu finden.
Dennoch wurde sowohl während Entwicklung des Prototypen in der
vorlesungsfreien Zeit und während der Iterationen in der
Vorlesungszeit Kernarbeitszeiten eingeführt, die die Kommunikation
stark erleichtert und motivierend auf die Entwickler gewirkt
haben.

Die Kernarbeitszeiten wurden während des Projekts durch Treffen des
Teams in angenehmer Athmosphäre ergänzt. Während der Treffen wurde von
den Teilnehmern über den Fortschritt berichtet und anstehende Aufgaben
verteilt.

\begin{figure}[h!]
  \centering
  \begin{tabular}[l]{rlrll}
    \multicolumn{1}{c}{\bf ID} & \multicolumn{1}{c}{\bf Bezeichnung} &
    \multicolumn{1}{c}{\bf Aufwand} & \multicolumn{1}{c}{\bf Zeitraum} &
    \multicolumn{1}{c}{\bf Meilenstein} \\
    \multicolumn{2}{c}{} &
    \multicolumn{1}{c}{(in Mh)} \\
    \hline
     1 & Analyse und Angebot & 135 & 01.05. - 29.06.03 & M1: Angebot \\
     2 & Spezifikation und Entwurf & 185 & 30.06. - 01.08.03 & \\
     3 & Prototyp Messe (1. Iteration) & 560 & 04.08. - 01.10.03 & M2: Prototyp Messe \\
     4 & 2. Iteration & 440 & 01.11. - 16.01.04 & \\
     5 & 3. Iteration & 420 & 19.01. - 19.03.04 & \\
     6 & Handbuch & 100 & 19.01. - 19.03.04 & \\
     7 & Auslieferung & 15 & 22.03.04 & M4: Auslieferung \\
     8 & Nachbesserung & 30 & 22.03. - 19.04.04 & \\
     9 & Abschlussbericht und Präsentation & 150 & 17.06.04 & \\
    \hline
       & & 2035\\
  \end{tabular}
  \caption{Projektablauf}
\end{figure}

Im Folgenden wird eine kurze Beschreibung der einzelnen Phasen und der
erreichten Ergebnisse angegeben. Zu den Iterationen sind jeweils nur
die wichtigsten Änderungen der Software angegeben. Eine detailierte
Liste ist auf der POA Internetseite\footnote{http://poa.berlios.de/changes-report.html} zu finden.

\subsection{Analyse und Angebot}

Während der Anforderungsanalyse wurde in mehreren Treffen die
Anforderungen des Kunden ermittelt. Die Ergebnisse wurden in einem
Angebot dokumentiert, das dem Kunden zur Abnahme vorgelegt wurde. Das
Angebot beinhaltete eine Beschreibung des geplanten Projekts (siehe
auch \ref{angebot}).

\subsection{Spezifikation und Entwurf}

In dieser Phase wurde eine Spezifikation erstellt, die Benutzungsfälle
beinhaltete und als internes Dokument zur Erstellung der
Benutzungsoberfläche verwendet wurde. In einem Grobentwurf wurde die
Architektur von POA festgelegt (siehe auch \ref{design}) und in einem
partiellen Feinentwurf die Schnittstellen des Datenmodells in Form
von Header-Dateien entwickelt.

\subsection{Prototyp (Erste Iteration)}

Der Prototyp wurde für eine Hausmesse am ISW entwickelt und für die
Präsentation des Offenen Antriebs verwendet. Der Fokus lag auf der
Entwicklung der graphischen Benutzungsoberfläche, die teilweise noch
funktionslose Dialoge beinhaltete. Die Oberfläche unterstützte bereits
das Anlegen und Speichern von Projekten. Die erstellen Blöcke konnten
auch mit automatisch gerouteten Linien verbunden und konfiguriert
werden, so dass die Kernfunktionalität von POA anhand von
Beispielprojekten auf der Messe erläutert werden konnte.

Die pünktliche Auslieferung des Prototypen und die damit verbundene
Erreichung des zweiten Meilensteins war ein erster Test, ob die
Umsetzung der Anforderungen mit den Vorstellungen des Kunden
übereinstimmte. Da sich die Rückmeldungen des Kunden als sehr positiv
erwiesen, wurde die Entscheidung getroffen, den Prototyp nicht zu
verwerfen, sondern als Basis weiter zu verwenden. Somit kann die
Entwicklung des Prototypen als erste Iteration bezeichnet werden.

Am 1.10.2003 wurde POA 0.1.0 dem Kunden im Rahmen einer Präsentation
ausgeliefert.

\subsection{Zweite Iteration}

Zu Beginn der zweiten Iteration wurde eine Refaktorisierung des
Quellcodes vorgenommen, um die während der Entwicklung des Prototypen
entdeckten Schwachstellen des Entwurfs zu beseitigen. Desweiteren
wurden Merkmale wie die manuelle Laufzeitoptimierung, die im
Prototypen nur als funktionslose Dialoge zur Verfügung standen,
implementiert. Der automatische Routing-Algorithmus wurde durch einen
zweiten Algorithmus ergänzt, der Überdeckungen mit anderen
Verbindungen und Blöcken berücksichtigt, aber weniger effizient ist.
Zur Qualitätssicherung wurde ein CppUnit basierter
Regressionstest eingeführt.

Zum Ende der Iteration wurde das bisher nur unter Linux entwickelte
Produkt auf Microsoft Windows portiert. Neben einigen syntaktischen
Korrekturen, die in Unterschieden zwischen den verwendeten Compilern
begründet sind, mussten kleinere plattformspezifische Eigenheiten der
Qt-Bibliothek umschifft werden.

Die Portierung, die oben beschriebene Refaktorisierung und die
zweiwöchigen Weihnachtsferien haben zu der Ausdehnung der Iteration
bis in den Januar geführt. 

Am 13.01.2004 wurde POA 0.2.0 im Rahmen einer Präsentation beim
Auftraggeber ausgeliefert. Am 16.01.2004 wurde eine für Windows
korrigierte Version 0.2.1 nachgeliefert.

\subsection{Dritte Iteration}

In der dritten Iteration wurden die bis dahin noch nicht
umgesetzten Anforderungen implementiert. Einige nicht geforderte,
aber auf Grund des erweiterbaren Entwurfs und der Mächtigkeit der
verwendeten Qt-Bibliothek sehr einfach zu implementierende Merkmale,
wurden außerdem eingebaut. Darunter eine Druckfunktion, die Netzwerke
aus Blöcken und CPUs ausgeben kann und die Möglichkeit mehrere
Projekte parallel zu öffnen. Desweiteren wurden frei positionierbare
Texte zu Projekten hinzugefügt und die Bibliothek erweitert, um vom
Benutzer konfigurierte Blöcke abzulegen. Als visuelle
Konstruktionshilfe wurde eine Legende eingeführt die durch farbliche
Schattierung die Taktrate der Blöcke anzeigt.

Auf Grund der grossen Anzahl an Erweiterungen und Fehlerkorrekturen
wurde während der Iteration entschieden, am 1.2.2004 die Version 0.3.0
auszuliefern. 

Daraufhin wurde POA zusätzlich zu der bisher verwendeten Sprache
Englisch auf Deutsch lokalisiert und die automatische Optimierung von
Signallaufzeiten implementiert.

Die anschließende Zeit wurde für ausgiebige Reviews des Quellcodes
verwendet. Abgesehen von einfach manuell testbaren Klassen der
Benutzeroberfläche wurde in fünf Review Sitzungen der größte Teil des
Quellcodes geprüft. Im Ergebnis wurden einige Hauptfehler und mehrere
Nebenfehler gefunden. Am positivsten haben sich die Reviews auf die
Dokumentation des Quellcodes und die Motivation diesen zu
dokumentieren ausgewirkt. Auf Grund der Erfahrungen der ersten Review
Runde wurde der Quellcode von den entsprechenden Entwicklern vor der
zweiten Runde bereits im Vorfeld der Reviews überarbeitet.

Im Nachhinein kann festgestellt werden, dass es sicherlich positive
Auswirkungen auf die Qualität gehabt hätte Quellcode Reviews bereits
zu einem früheren Zeitpunkt und regelmäßig durchzuführen.

Im Anschluss an die Reviews wurde ein umfangreicher Systemtest
durchgeführt, um die graphische Benutzeroberfläche zu prüfen. Aufgrund
des erstellten Testprotokolls konnten mehrere Fehler in der
Software behoben werden.

Am 25.3.2004 wurde POA 1.0.0 im Rahmen einer Präsentation an den
Kunden ausgeliefert.

\subsection{Handbuch}

Das Handbuch wurde von einem einzelnen Entwickler parallel zur dritten
Iteration erstellt. Es enthält eine Referenz und ein Tutorial (siehe
auch \ref{handbuch}). Das Handbuch wurde in einem Review geprüft und
zusammen mit POA 1.0.0 ausgeliefert.

\subsection{Auslieferung}

Die während der Präsentation ausgelieferten Ergebnisse sind in den
beiden vorhergehenden Abschnitten beschrieben. Die Auslieferung
markierte mit der Erfüllung der Projektanforderungen das vorläufige
Ende des Projekts.

\subsection{Nachbesserung}

Im Anschluss and die Auslieferung wurde eine vier-wöchige
Nachbesserungsphase gewährt. Es sollten lediglich Fehler behoben
werden, aber keine neuen Anforderungen umgesetzt werden. Da keine
Fehler gemeldet wurden, wird POA 1.0.0, abgesehen von einer
kosmetischen Änderung, am 17.6.2004 als Version 1.0.1 endgültig
ausgeliefert werden.

\subsection{Abschlussbericht und Präsentation}

Der Abschlussbericht ist das vorliegende Dokument. Die
Abschlusspräsentation ist für den 17.6.2004 am ISW geplant. Zusammen
mit einem ausgedruckten Exemplar des Abschlussberichts wird ein Poster
mit einer UML Darstellung der POA Architektur und eine CD, die
sämtliche Projektergebnisse beinhaltet, ausgeliefert werden.

\section{Arbeitszeitverteilung}

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{zeitverteilung}
  \caption{Zeitliche Aufwandsverteiung auf die Entwickler}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=10cm]{phasenverteilung}
  \caption{Zeitliche Aufwandsverteilung auf die Aktivitäten}
\end{figure}

\section{Werkzeuge}

Für die Entwicklung wurden zahlreiche Werkzeuge eingesetzt. Die Wahl
war den Entwicklern freigestellt sofern die vereinbarten Richtlinien
eingehalten wurden. Bei der Wahl von Dokumentenformaten wurde darauf
geachtet dass für alle eingesetzten Plattformen freie Werkzeuge zur
Bearbeitung verfügbar waren.

\subsubsection{Bibliotheken}

Die für die Implementierung von POA eingesetzten Bibliotheken sind:

\begin{itemize}
\item Trolltech Qt
  3.0.5\footnote{http://www.trolltech.com/products/qt/}
\item QExtSerialPort 0.5 von Wayne Roth zur Ansteuerung der seriellen
  Schnittstelle
\item CppUnit 1.9.11\footnote{http://cppunit.sourceforge.net/} als
  Regressionstest Framework
\end{itemize}

\subsubsection{Maven}

Besondere Erwähnung soll das Werkzeug Maven finden. Maven wurde für
die Generierung der Projektseite im Internet benutzt. Maven bietet
die Möglichkeit eine anschauliche Projektdokumentation auf einfache
Art und Weise zu erstellen. Die Dokumentation enthält unter anderem
Informationen über die Entwickler, den Quellcode und die
Projektablauf. Damit konnte sowohl für den Kunden als auch für die
Entwickler eine hohe Transparenz erreicht werden.

Einer der von Maven generierten Berichte wird von mit dem von Tammo
van Lessen und Steffen Pingel entwickelten Analysewerkzeug StatCVS-XML
erzeugt. Die mit StatCVS-XML generierten Statistiken aus der CVS
Aktivität (siehe auch \ref{cvs analyse}) wurden währen der Iterationen
laufend aktualisiert. StatCVS-XML ermöglicht einen direkten Vergleich
der Entwickler untereinander und hat im POA Projekt zu einem
motivierenden Ansporn geführt. 

\subsubsection{Berlios}
\label{berlios}

Verwaltet wurde das Projekt auf der Open-Source Platform Berlios, die
vom Frauenhofer Institut betrieben wird. Berlios bietet vielfältige
Unterstützung wie z.B. eine Internetseite, einen Downloadbereich,
Mailinglisten und ein Quellcode Repository (CVS). Zum Bedauern des
Teams ließ die Verfügbarkeit von Berlios in den letzten Wochen des
Projekts stark zu wünschen übrig und erschwerte so den
Informationsaustausch.

Ergänzend zu Berlios wurde auf ein ähnliche Plattform mit dem Namen
DuckForge an der Fakultät für Informatik und Elektrotechnik zur
Erfassung der Arbeitszeit zurückgegriffen. Leider zeichnet sich die
Zeiterfassung von DuckForge nicht durch intuitive Bedienung und hohe
Geschwindigkeit aus.

\subsubsection{Jira}
\label{jira}

\begin{figure}[h!]
  \centering
  \includegraphics[width=14cm]{jira}
  \caption{Jira Road Map Ansicht}
\end{figure}

Die Tracker Funktionalität von Berlios wurde nicht benutzt.
Stattdessen wurde Jira von Atlassian eingesetzt, die freundlicherweise
eine kostenlose Lizenz für das POA Projekt zur Verfügung stellten.
Jira ist ein webbasiertes Trackersystem, das auf einem von Tammo van
Lessen zur Verfügung gestellten Server betrieben wurde. Jira
ermöglicht eine detailierte Erfassung von Aufgaben und Fehlerberichten
inklusive einer Zeitabschätzung und Fortschrittserfassung. Letzteres
war sehr hilfreich bei der Planung und Kontrolle der Iterationen. Jira
bietet einfache Bedienbarkeit und übersichtliche
Analysefunktionen. 

Die geprüften Open-Source Alternativen wie Bugzilla sind weniger
intuitiv zu bedienen und in Bezug auf die Analysen nicht ausreichend
mächtig zur Erfassung von Aufgaben. Jira kann zur Erfassung von
Fehlerberichten und Aufgaben empfohlen werden. Allerdings sollte der
nicht triviale Administrationsaufwand, der Kenntnisse im J2EE Bereich
voraussetzt, nicht unterschätzen werden. Durch einen Fehler bei der
Installation war es zu einem fortgeschrittenen Zeitpunkt des POA
Projekts leider notwendig die Jira erneut zu installieren und die
Datenbank mit erfassten Berichten zu löschen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Statistische Analyse}

\section{Versions Kontrolle}
\label{cvs analyse}

\subsubsection{Quellcodeumfang}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{loc}
  \caption{Quellcode Zeilenanzahl über die Zeit}
\end{figure}

Das Diagramm zeigt die gesammte Zeilenanzahl des Quellcodes inklusive
aller Kommentarzeilen über die Laufzeit des Projekts. Die vertikalen
gestrichelten Linien geben die Versionsmarkierungen an, zu diesem
Zeitpunkt wurde jeweils eine lauffähige POA Version an den
Auftraggeber ausgeliefert.

An dem Diagramm lassen sich sehr gut die Iterationen ablesen. Die
erste Iteration erstreckt sich vom Anfang des Diagramms bis zur ersten
gestrichelten Linie. Der Sprung am Anfang ist durch die Übernahme der
während des Entwurfs enstandenen Header-Dateien zu erklären. Die
Leerlaufphase im Oktober ist durch die Hausmesse und den Anfang des
Semesters bedingt. Nach der Überprüfung des Quellcodes ist die
Refaktorisierung deutlich erkennbar. Ende November wurde zeitweise
mehr Quellcode entfernt als eingefügt. Im folgenden ist die Zunahme
der Quellcodezeilen nach der Weihnachtspause wieder linear bis zur
Fertigstellung von POA.

\subsubsection{Umfang der Module}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{size_by_module}
  \caption{Verteilung der Quellcode Zeilenanzahl auf die Module}
\end{figure}

Dieses Diagramm zeigt Größenverhältnisse der Module, gemessen in
Quellcodezeilen. Es ist zu berücksichtigen, dass der Anteil der
graphischen Benutzeroberfläche (GUI) weit höher ist als das Diagramm
vermuten lässt. Nahezu alle Module enthalten eine graphische
Benutzerschnittstelle in Form von Dialogen, die Teile der
Programmlogik implementiert und in dem Diagramm zu dem jeweiligen
Modul gezählt wurden. Die View Komponente besteht ausschliesslich aus
Anzeigeklassen und ist Submodul der GUI. 

Zu bedauern ist der geringe Anteil des Test Moduls. Gemessen wurden
die Klassen des Regressionstest. Erklärt werden kann dies mit dem
hohen Anteil an schwierig automatisiert testbarem GUI Quellcode. 

\subsubsection{Entwicklerkooperation}

\label{developer by file}
\begin{figure}[h!]
  \centering
  \begin {tabular}[l]{ll}
    \hline
    Dateiname & Entwickleranzahl \\
    \hline
    src/poa.cpp & 6 \\
    src/mainwindow.cpp & 6 \\
    src/librarywindow.cpp & 6 \\
    src/blockmodel.cpp & 6 \\
    src/settings.h & 5 \\
    src/scheduledialog.cpp & 5 \\
    src/project.h & 5 \\
    src/project.cpp & 5 \\
    src/poa.h & 5 \\
    src/pinview.h & 5 \\
    \hline
  \end {tabular}
  \caption{Anzahl Entwickler pro Datei (Top 10)}
\end{figure}

Diese Tabelle zeigt zu einer Liste von Quellcode-Dateien die Anzahl
von Entwicklern, die jeweils gemeinsam an einer Datei gearbeitet haben.
Es sind nur die Top zehn Dateien angegeben, aber auch in einer Liste
aller Dateien würden sich nie weniger als zwei Bearbeiter pro Datei
finden lassen. 

Es gab innerhalb des Teams für die Implementierung eines Moduls
jeweils einen bekannten zuständigen Entwickler, der im besonderen mit
dem Quellcode vertraut war. Mit diesem wurde vor grösseren Änderungen
innerhalb seines Zuständigkeitsbereichs durch andere Entwickler
Rücksprache gehalten, so daß Konflikte im vorraus vermieden werden
konnten. Kleinere Änderungen oder Fehlerkorrekturen konnten im
Zweifelsfall auch nachträglich oder über das Quellcode Repository
kommuniziert werden.

Diese Form des ``Collective Code Ownership'' ist sehr positiv zu
bewerten. Es hat Reibungsverluste bei Änderungen und die Entstehung
von Quellcode, der nur von einem einzelnen Entwickler verstanden und
gewartet werden kann, vermieden. Alleine durch die Kenntniss, daß
Quellcode von anderen gelesen wird, konnte die Lesbarkeit und Qualität
erhöht werden.

\subsubsection{Arbeitzeit}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{commit_by_hour}
  \caption{Uhrzeiten der CVS Repository Aktivität}
\end{figure}

Das Diagramm zeigt die Uhrzeiten der Aktivitäten im Quellcode
Repository. Eine höhere Anzahl Commits bedeutet eine höhere
Aktivität. Typisch ist die erhöhte Aktivität zwischen 15 und 18 Uhr,
die auch bei anderen Studienprojekten zu beobachten
ist. Offensichtlich ist das eine übliche Zeit das Arbeitsergebnis z.B.
zum Ende der Kernarbeitszeit in das Repository zu
comitten. Bemerkenswert sind die Aktivitäten nach 22 Uhr, die bis in
die Morgenstunden reichen. Vollkommen atypisch die Commits zwischen
7 und 8 Uhr. Es könnte vermutet werden, daß hier ein Frühaufsteher am
Werk war. Die näherere Betrachtung des POA Teams läßt diese Vermutung
allerdings sehr unwahrscheinlich erscheinen. Es gibt eine ausgeprägte
Bandbreite von bevorzugten Arbeitszeiten wobei die Nachtarbeiter
eindeutig die Mehrheit im Team stellen. 

\subsubsection{Entwicklung des Quellcodes}

\begin{figure}[h!]
  \centering
  \includegraphics[height=20cm]{evolution}
  \caption{Änderungshistorie der Versionen}
\end{figure}

Die Versionshistorie, auch Software Evolution genannt, zeigt die
Art der Veränderung zwischen den einzelnen Versionen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Persönliche Berichte}

\section{Necati Aydin}

\begin{center}
\includegraphics[width=5cm]{Fotos/necati}
\end{center}

\subsection{Tätigkeiten}

POA war für mich das erste Projekt in dieser Größenordnung. Da ich das
StuPro B vor StuPro A machen durfte, hatte ich noch keine Erfahrungen
gesammelt, die ich in POA einbringen konnte, wie manch ein anderer in
diesem Projekt. Qt war für uns alle noch Neuland, doch das war auch
eine weitere Herausforderung. Für mich pesönlich kam noch erschwerend
dazu, dass ich mit Softwareentwicklung in dieser Größe keine
Erfahrungen hatte und die Programmierspache C++ für mich auch neu
zuerlernen war.
 
In den frühen Phasen des Projekt war ich weitesgehend an
qualitätssichernden Maßnahmen beteiligt. Zu diesen Maßnahmen gehörten
Reviews bzw. Walkthroughs des Angebots, der Spezifikation und des
Entwurfs. Parallel dazu war ich bemüht mich in QT und C++
einzuarbeiten. Ebenso musste ich mich in Latex einarbeiten, welches
ich bis dato nicht kannte. Latex wurde zur Erstellung der meisten
Dokumente eingesetzt.

Während der ersten Implementierungsphase hatte ich anfangs einige
Probleme mich in den bis dahin entstandenen Code einzuarbeiten, da ich
mir eine etwas längere Auszeit in der vorlesungsfreien Zeit, wegen
Arbeit und Urlaub, genommen hatte.

In der zweiten Implementierungsphase, nach der Präsentation des
Prototyps im Oktober, hatte ich die Aufgabe ein geeignetes
Testframework für Unittests zu finden. Also schaute ich mich ein wenig
um, und es gab eigentlich nur CppUnit und QtUnit. CppUnit lehnt sich
das ursprünglich simple JUnit, ist aber unglaublich aufgebläht und
verkompliziert, allerdings gut dokumentiert. QtUnit ist komplett
undokumentiert, und daher sehr schwierig gewesen, zum Laufen zu
bringen. Um größere Komplikationen zu vermeiden, entschied ich mich
für CppUnit und passte es für unsere Zwecke an.

In der letzten Phase des Projekts war ich mit dem Schreiben des
Handbuchs beauftragt.  Dafür musste ich mich mit Latex intensiv
beschäftigen. Beim Schreiben des Handbuchs führte ich auch einige
Abnahmetests aus, wodurch ich einige Fehler aufdecken konnte, und
diese an die jeweiligen Entwickler weiterleitete.

Desweiteren nahm ich an fast allen Reviews als Gutachter bzw. als
Autor im Laufe des Projekts teil, und war teilweise an der Erstellung
dieses Dokoments beteiligt.

\subsection{Beurteilung}

Meiner Meinung nach ist POA ein voller Erfolg. Die Anforderungen des
Kunden wurden laut ihm zu seiner Zufriedenheit erfüllt. Das Projekt
war zu keiner Zeit in irgendeiner Weise bedroht, was sicherlich zum
Einen an der Führungsrolle des Projektleiters und zum Anderen am Team
selbst lag.

Was mich positiv überrascht hat, ist der Zusammenhalt unseres Teams.
Es gab zu keiner Zeit zwischenmenschliche Konflikte, was über einem
Zeitraum von einem Jahr mit 7 unterschiedlichen Persönlichkeiten nicht
selbstverständlich ist.

Was ich persönlich aus diesem Projekt mitnehmen werde, ist das
Erlernen einer neuen Programmiersprache, der Umgang mit CVS, Latex und
dem Toolkit Qt, und die positive Erfahrung bezüglich des
Teamverhaltens.

\newpage
\section{Anselm Garbe}

\begin{center}
\includegraphics[width=5cm]{Fotos/anselm}
\end{center}

\subsection{Tätigkeiten}
Seit Projektbeginn war ich neben den allgemeinen
Entwicklungstätigkeiten für das Configuration Management verantwortlich,
welches die Aufstellung von Richtlinien zur Toolunterstützung, u.a. zu
CVS, ssh und TeX beinhaltete, sowie die Pflege und Wartung des
Projekt-Repositories und der Mailinglisten. Die Pflege des
Projektrepositories und der Mailinglisten waren eine permanente Aufgabe
bis zum Projektende. Hierzu gehörte u.a. auch die Sicherung von
automatischen Backups zu POA.

Am Projektbeginn war ich an der Spezifikations- und Angebotserstellung
beteiligt, vor allem mit dem Fokus auf die GUI und Codegenerierung.
Grundlage des Angebotes und der Spezifikation war eine detaillierte
Anforderungsanalyse die durch verschiedene Kundengespräche durchgeführt
wurde.

Zusammen mit Steffen Keul erstellte ich einen Grobentwurf, der
grundlegend das MVC Design Pattern propagierte, dass integraler
Bestandteil von POA während der gesamten Entwicklung blieb.

Aufgrund meiner C++ Kenntnisse aus der Zeit vor meinem Studium, die auch
verschiedene windows-basierte GUI Anwendungen zur Folge hatten sowie aufgrund
meiner C Kenntnisse aus einem OpenSource Projekt wählte ich als
Seminarthema das ``Qt Toolkit'' welches eine portable OpenSource
Plattform (für nicht-kommerzielle Projekte) bietet, die unter Windows,
Unix und Mac OS X lauffähig ist und dem POA Team einen initialen
Anleitungsfaden vermitteln sollte.

Zu Beginn der Implementierungsphase in der ersten Iteration entwickelte
ich zusammen mit Steffen Pingel eine Qt-basierte POA Rahmenanwendung,
die eine MDI (Multiple Document Interface) Architektur 
sowie den qmake-basierten Buildprozess unterstützte.
Zu dieser Zeit evaluierte ich auch, dass wir auf die
Entwicklungsunterstützung durch den Qt (GUI) Designer verzichten, da
dieser nur absolute Widget-Positionierung unterstützt und 
umständlichen Code generiert - die GUI Entwicklung im POA Projekt fand
weitestgehend ohne Unterstützung des Qt-Designers statt bzw. ist in der
Rückbetrachtung vollkommen unabhängig von diesem verlaufen.

Während der Implementierungsphase war ich für die Entwicklung des
Block-Konfigurations\-dialoges, sowie des (De)Mux-Konfigurationsdialoges
zuständig, sowie mit der Integration der damit zusammenhängenden Models
(CPU-, Block-, Mux- und PinModel). Darüber hinaus entwickelte ich den
CodeManager für die Konfiguration und Editierung von CPUs. Dieser führt
automatische Substitutionen des Quellcodes durch, der alle Ein- und
Ausgänge (Pins) der CPU-Konfiguration als Variablen (NIOS Address
Pointer) zur Verfügung stellt. Hierzu zählte auch die Entwicklung eines
internen Ausgabeterminals, das Compiler-Ausgaben in einen POA Dialog
umleitet, um den Status und Fortschritt der Compilierung des Quellcodes
einer CPU zur Verfügung stellt.

Neben meiner Entwicklungstätigkeit nahm ich auch an verschiedenen
Reviews des Quellcodes und des Handbuchs teil, die zur
Qualitätssicherung durchgeführt wurden.

\subsection{Beurteilung}

Rückblickend betrachtet verlief die POA Entwicklung ohne nennenswerte
Konflikte im Team. Die Zusammenarbeit mit den anderen Entwicklern war
durchweg harmonisch. Trotz der weitestgehend autonomen
Entwicklertätigkeiten funktionierte die Modulintegration durch kurze
Absprachen sehr gut, mir ist rückblickend fast kein Zeitpunkt bekannt,
an dem die POA Applikation im CVS nicht compilierfähig gewesen wäre.

Ich empfand die durchweg kollegiale und lockere Entwicklerführung durch
den Projektleiter Steffen Pingel als angenehm und motivierend.
Alle Entwickler konnten aufgrund der nur kurzen Kernarbeitszeit ihre
Aufgaben weitestgehend autonom lösen. Neben der eigentlichen
Entwicklertätigkeit trafen sich die Entwickler auch spontan zu privaten
Arrangements.

Aus ökonomischer Sicht stellt sich mir durch Vergleiche mit
kommerziellen Projekten durch meine werkstudentische Tätigkeit sowie
meines viermonatigen Industriepraktikums bei der
Firma Danet IS GmbH in Stuttgart die POA Entwicklung als voller Erfolg
dar, da der Zeitrahmen nicht überzogen wurde und somit sich die Kosten im
Rahmen des für Studienprojekte vorgesehenen Zeitaufwands beliefen.

Daß die POA Entwicklung ein voller Erfolg war, dürfte vor allem auf die
Team-Zu\-sam\-men\-set\-zung zurückzuführen sein.

\newpage
\section{Stefan Hauser}

\begin{center}
\includegraphics[width=5cm]{Fotos/stefan}
\end{center}

\subsection{Team}
Das POA-Team war eine Gruppe, deren Teilnehmer sehr unterschiedliche 
Startvoraussetzungen hatten: Etwa die H"alfte des Team war Mitten im 
Studienprojekt A, also in der heißen Codierungsphase. Die andere
H"alfte hat mit dem Studienprojekt B zuerst begonnen und bisher noch 
keine Erfahrungen mit Projekten dieser Gr"oße. Auch das technische
Wissen war unterschiedlich: Ein Teil des Teams beherrschte C++ schon 
perfekt, f"ur die anderen war dies noch Neuland. \newline

Da ich mit POA mein erstes Studienprojekt bestritt und bisher noch
keine Erfahrungen in C++, jedoch aus dem vorangegangenen
Software-Praktikum in Java hatte, erhoffte ich mir zu Beginn
des Projekts einen großen Wissensgewinn, durch den Know-How-Transfer
zwischen des Team-Mitgliedern. \newline

Die Entscheidung f"ur POA war aus meiner Sicht die richtige, denn wir 
bildeten ein schlag\-kräf\-tiges Team und auch der Kontakt mit Christian
Kramer war kollegial, immer schnell hergestellt und
unproblematisch. Der hervorragende Projektverlauf spiegelt sich auch
darin wieder, dass wir nie auf die Hilfe unseres Betreuers angewiesen
waren, sondern alle Problemstellungen selbst"andig oder in Absprache
mit Christian Kramer l"osen konnten.\newline

\subsection{Seminar}
Meine Seminararbeit besch"aftigte sich mit den M"oglichkeiten des
manuellen und automatischen Routens von Leiterbahnen zwischen
Funktionsbl"ocken auf Platinen. Also dem Erstellen eines
Platinenlayouts. Mein erster Ansaz den ich verfolgte, war die Idee,
das Routing mit Hilfe eines evolution"aren Algorithmuses automatisch 
durchzuf"uhren. Dieses Konzept stellte ich im ersten Teil der
Seminararbeit vor. Doch ich verwarf die Idee wieder, da sich die
Algorithmen zwar auf verschiedene Kriterien, wie zum Beispiel minimale 
Platinenfl"ache oder k"urzeste Leiterwege, optimieren lassen, wir
jedoch f"ur unsere Anwendung eine Optimierung zur leichten
Verst"andlichkeit der Schaltung, also einer gute Darstellung
w"unschten, was sich aber nicht algorithmisch ausdr"ucken l"asst. 
Der zweite Teil der Seminararbeit besch"aftigte sich somit mit den 
M"oglichkeiten des manuellen Routings und welche Techniken zum
Beispiel in CAD-Anwendungen verwendet werden um den Benutzer dabei zu 
unterst"utzen. Die Arbeit schließt dann mit der Vorstellung eines
Konzepts zur konsistenten Speicherung des Layouts. \newline

POA sieht in Version 1.0 "ubrigens auch ein automatisches Routing
vor. Die Idee, die hier dahinter steckt  ist, daß ein
"uberkreuzungsfrei gezeichneter, sprich planarer Graph leichter 
verst"andlich ist, als einer, in dem sich die Leitungen "uberkreuzen und
darauf, dass die Positionen der Funktionsbl"ocke beim Routing als vom 
Benutzer fest vorgegeben  angenommen werden.\newline

\subsection{Aufgaben}
W"ahrend der Angebotserstellung habe ich zusammen mit Anselm Garbe
eine Anforderungsanalyse durchgef"uhrt, das Mengenger"ust erstellt und 
am Begriffslexikon mitgearbeitet. Schließlich entwarf ich einen
funktionslosen Prototypen der Benutzungsoberfl"ache, der so auch in
der ersten Iteration von POA umgesetzt wurde. W"ahrend der
Entwurfsphase wirke ich in Reviews mit.\newline

Bei der Codierung beteiligte ich mich bei der Erstellung der 
Benutzungsoberfl"ache und erstellte die erste Version der 
``Deploy-Projekt''-Funktionalit"at, zu der auch die M"oglichkeit
geh"rt, den Quellcode zu compilieren und auf den ``Offenen Antrieb'' 
herunterzuladen und auszuf"uhren. Dazu wurde bisher ein keines
C-Programm verwendet, das jedoch plattformabh"angig war und nicht
unter Linux lief. Ziel war es den Download in POA so zu
implementieren, dass er sowohl unter Linux als auch unter Windows die 
serielle Schnittstelle  zum herunterladen des ausf"uhrbaren Programms 
verwenden konnte. Dazu forschte ich nach eine frei erh"altlichen
Bibliothek f"ur QT, die plattformabunabh"angigen Zugriff auf die
serielle Schnittstelle erm"oglicht und wurde in QExtSerialPort
f"undig. Mit Hilfe dieser Bilbliothek konnte der Download in POA 
platformunabh"angig realisiert werden.\newline

Anschließend implementierte ich die Funktion, die in POA verwendete
Sprache zu "andern. Dazu passte den vorhandenen Code, soweit noch
nicht geschehen, f"ur die Verwendbarkeit mit mehreren Sprachen an und 
"ubersetzte alle Texte vom englischen ins deutsche.\newline

Schliesslich f"uhrten wir einige Code-Reviews durch, an denen ich
ebenfalls teilnahm und beschlossen noch weitere Test von der
Oberfl"ache aus durchzuf"uhren, da dieser Teil bei den bisherigen
Tests mit gcov noch nicht ausreichend abgedeckt war. Dazu erarbeitete
ich eine Reihe von Testf"allen, entwickelte einen Testplan und f"uhrte 
die Tests durch.\newline

Gegen Ende des Projekts nahm ich noch an Handbuch-Reviews teil und
habe die CD erstellt sowie verschiedene Dinge f"ur den
Abschlussbericht und die Abschlusspr"asentation erledigt.\newline

\subsection{Fazit}
Meine Erfahrungen, sowohl ``soft skills'', als auch Kenntnisse "uber 
Werkzeuge, die wir w"ahrend unseres Projekts verwendet haben (z.\ B. 
LaTeX, das Zeiterfassungstool oder CVS) kann ich jetzt in meinem
zweiten Projekt, das inzwischen schon ein halbes Jahr l"auft,
einbringen. Dort bin ich der einzige, der schon Softwareprojekt-
Erfahrungen hat, und kann dementsprechend oft den entscheidenen Tipp
f"ur oder gegen ein bestimmtes Vorgehen oder zu verwendetes Werkzeug
geben. Insofern kann ich schon jetzt vom meinem erlangten Wissen
profitieren, ein wirklich positives Fazit ziehen und mich bei allen 
Team-Mitgliedern f"ur die gute Zusammenarbeit bedanken.

\newpage
\section{Steffen Keul}

\begin{center}
\includegraphics[width=5cm]{Fotos/steffen_k}
\end{center}

\subsection{Aufgaben}

Zu Beginn des Projekts wurden keine bestimmten Rollen zugewiesen. Es
war vielmehr eine Anforderung an jedes Team-Mitglied, den Überblick
über das gesamte Projekt zu behalten und bei Bedarf an bestimmte
Detailproblemen arbeiten zu können.

\subsection{Tätigkeiten}

\subsubsection{Seminar}

In meinem Seminarvortrag untersuchte ich das Problem der Berechnung
eines optimalen Scheduling für die POA-Plattform. Da für die
speziellen Anforderungen des Offenen Antriebs keine bekannten Lösungen
existieren, analysierte ich die genauen Anforderungen an eine
algorithmische Lösung des Problems. Diese Anforderungsanalyse diente
später als Grundlage für die Implementierung von POA.

\subsubsection{Anforderungsanalyse}

Während der Anforderungsanalyse nahm ich an allen Kundengesprächen und
internen Besprechungen teil.

\subsubsection{Entwurf}

Gemeinsam mit Anselm Garbe erstellte ich einen Grobentwurf für das
POA-System. Die Tauglichkeit unseres ersten Vorschlags wurde dann in
einer Review-Sitzung evaluiert und wir konnten noch einige
Vereinfachungen in den Entwurf integrieren.

Das Ergebnis des Entwurfs waren kommentierte Klassendeklarationen, die
während der Implementierung in die POA-Codebasis übergingen. Die
grundlegende Struktur des Entwurfs bewährte sich in POA und ist im
fertigen Produkt erhalten geblieben.

\subsubsection{Implementierung}

Zu Beginn der Implementierung nahm ich vielfältige Funktionen
war. Diese schlossen Diskussionen über die Programmiersprache C++ ein
sowie die konkrete Gestaltung des Codes, um Konformität zu dem Entwurf
sicher zu stellen. Die Sprache C++ wird im Grundstudium der
Softwaretechnik nicht gelehrt und war deshalb für einige
Team-Mitglieder neu. Ich selbst hatte zwar vor Beginn meines Studiums
schon einige Jahre damit gearbeitet, musste mein Wissen aber zu Beginn
des Projekts etwas auffrischen.

Im weiteren Verlauf des Projekts wendete ich mich zunehmend den
algorithmisch aufwendigeren Problemen des Projekts zu. Ich entwarf und
implementierte zwei verschiedene Verfahren zur automatischen
Layoutberechnung und den Algorithmus zur automatischen Berechnung des
Scheduling.

Das erste Verfahren zur Layoutberechnung basiert auf einer Sequenz von
Entscheidungen und berechnet in konstanter Zeit ein Layout für einen
eizelnen Konnektor. Dieses Verfahren ist extrem effizient und kann
angewendet werden, während ein Block verschoben wird, um die
verbundenen Konnektoren entsprechend anzupassen.

Das zweite Verfahren basiert auf dem bekannten Algorithmus von
Dijkstra. Dieses Verfahren wird angewendet, um einen einzelnen
Konnektor in ein bestehendes Netzwerk zu integrieren. Dabei wird der
neue Konnektor mit einer minimalen Anzahl an Kreuzungen mit anderen
Objekten und einer minimalen Anzahl an Knickpunkten gezeichnet.

Zur Berechnung eines optimalen Scheduling für POA konnte ich in der
Literatur kein geeignetes Verfahren finden. Für meinen Seminarvortrag
hatte ich eine Lösung entworfen, die sich einem evolutionären
Verfahren bedient. Mit dem Fortschritt des Projekts konnte ich aber
einen besseren Einblick in potentielle Anwendungen von POA gewinnen
und fand eine weniger rechenaufwendige Lösung, die für die meisten
Netzwerke trotzdem optimale Ergebnisse berechnet.

Der Benutzer kann eine Liste von priorisierten Wegen durch das
Netzwerk vorgeben, die in der angegebenen Reihenfolge optimiert
werden. Der erste Weg wird garantiert eine minimale Signallaufzeit
erhalten. Für die weiteren Wege der Liste kann das Ergebnis durch die
bereits berechneten Eigenschaften der vorherigen Wege verschlechtert
werden. In den getesteten Beispielen konnte stets ein optimales
Scheduling gefunden werden. Die konkrete Implementierung des
Verfahrens lässt auch zu, dass Parameter einzelner Blöcke manuell
vorgegeben werden und nicht das gesamte Scheduling automatisch
berechnet wird.

\subsubsection{Validierung}

Ich erstellte Testprogramme für die Teile meines Codes, bei denen ein
automatischer Test sinnvoll erschien. Für das automatische Scheduling
oder das automatische Layout wäre ein automatisierter Test jedoch
nicht machbar gewesen. Es ist kaum möglich, automatisiert
festzustellen, ob ein Layout den Anforderungen entspricht oder ob ein
Scheduling tatsächlich optimal ist. Stattdessen führte ich durch
systematisches Ausprobieren des Programms einen explorativen Test
durch.

Außerdem führten wir Code-Reviews durch an denen ich als Gutachter
sowie als Autor beteiligt war. In diesen Reviews konnten einige Fehler
identifiziert und später beseitigt werden.

\subsubsection{Projektabschluss}

Ab dem 22. März war ich nicht mehr in Stuttgart vor Ort, sondern
begann mein Industriepraktikum in Portland OR., USA. Die aktive Phase
des Projekts war zu diesem Zeitpunkt bereits beendet, da die
Projektlaufzeit insgesamt jedoch etwas länger war, als ursprünglich
veranschlagt, konnte ich zum Projektabschluss nicht anwesend sein.

Ich arbeitete jedoch von Portland aus an dem Entwurfsdokument und dem
Abschlussbericht mit.

\subsection{Einschätzung des Projekts}

Ich werte POA als Erfolg. Die Anforderungen an POA waren zu keinem
Zeitpunkt klar fixiert, sondern POA war Teil eines größeren Projekts,
dessen Richtung noch nicht bis ins letzte Detail feststand. Das von
uns angewendete Prozessmodell halte ich deshalb für richtig gewählt,
da es uns ermöglichte dem Kunden erste Ergebnisse zu präsentieren und
dann aufgrund seines Feedbacks das weitere Vorgehen anzupassen.

Die Arbeit im Team empfand ich als sehr angenehm. Die einzelnen
Team-Mitglieder waren kompetent und hilfsbereit. Die Projektleitung
ging auf individuelle Eigenschaften der Entwickler ein und führte das
Team ohne einschränkend zu wirken. Der Kontakt zum Kunden war direkt
und unkompliziert.


\subsection{Persönlicher Lernerfolg}

Als Ergänzung zu den Vorlesungen im Anwendungsfach gewann ich durch
das Projekt einen besseren Einblick in die Regelungstechnik und den
Aufbau eines Regelkreises.

Ich lernte das Toolkit Qt kennen. Ich hatte Gelegenheit mich mit
algorithmischen Aufgabenstellungen aus der Praxis auseinander zu
setzen. Hier konnte ich den Nutzen meiner theoretischen Ausbildung
erproben, da sich diese Probleme zumindest teilweise auf
Standardalgorithmen zurückführen ließen.

Schließlich fand ich es interessant, ein iteratives Prozessmodell zu
erleben. Obwohl ich dieses Vorgehen nach wie vor nicht für optimal
halte, fand ich es sehr lehrreich mich mit Vor- und Nachteilen dieses
Vorgehens in der praktischen Anwendung auseinander zu setzen.

\newpage
\section{Marcel Kilgus}

\begin{center}
\includegraphics[width=5cm]{Fotos/marcel}
\end{center}

\subsection{Aufgaben}
Aufgrund meiner weit über 10 Jahre Erfahrung mit Maschinencode und der
Emulation von Prozessoren oblag mir das Seminarthema der
Laufzeitmessung von Altera NIOS CPUs. Dazu wurden verschiedene
Verfahren evaluiert, vom einfachen Profiling bis zum Schreiben eines
kompletten CPU Simulators. Letztendlich sind die Rahmenbedingungen
einer Ausführung im CPLD aber so vielen Faktoren unterworfen dass dies
nicht mit vertretbarem Aufwand und vor allem nicht in der benötigten
Präzision möglich war. Die einzig ver\-blei\-ben\-de Option einer
hardwaregestützten Instrumentierung des Codes inklusive Ausführung auf
einem realen CPLD konnte im Rahmen des Projekts leider nicht weiter
verfolgt werden.

Der Kunde verlangte von uns primär eine Windows Applikation, mit der
Option später auf Linux wechseln zu können. Zu diesem Zweck wurde die
Qt-Bibliothek von Trolltech als Basis für POA bestimmt. POA an sich
wurde größtenteils unter Linux entwickelt, als einzigem mit substantieller
Erfahrung in der der Windows Programmierung im Team oblag es mir die
``Redmond''\footnote{Für die nicht Eingeweihten: Firmensitz der
  Microsoft Corporation} Kompatibilität des Codes sicherzustellen.
Zuerst wurde dies erreicht mit der Hilfe des MinGW Compilers, einem
GCC Port für Windows. Da aber nur Microsoft Visual C++ offiziell von
Trolltech für Windows unterstützt wird und dieser Compiler auch noch
andere Vorteile mit sich bringt (IDE mit integriertem Debugger,
schnellerer Übersetzer, kompakterer Code), lag es an mir die
Unterschiede der beiden Compiler zu bestimmen und den vorhandenen Code
in einer Art anzupassen, die auf beiden Plattformen lauffähig ist.

Auch im weiteren Verlauf der Entwicklung habe ich neue Codeblöcke und
Code Änderungen evaluiert und gegebenenfalls wieder an Visual C++
angepasst.  Dies umfasste sowohl kleinere Syntaxänderungen als auch
Änderungen an Objektstrukturen (einige Abstürze unter Windows konnte
ich auf Probleme mit der RTTI\footnote{Runtime Type Information}
zurückführen).

Ich habe einen ersten Prototyp des Scheduling Dialog erstellt, den
dann Tammo aus damaligen zeitlichen Engpässen weiterentwickelt hat.

Weiterhin zeichnete ich mich für die Druckfunktionalität sowohl für
die Netzwerke als auch für die Scheduling Übersicht verantwortlich.

Außerdem oblag es mir das manuelle Routen von Verbindungen zu
implementieren.  Nach einigen mehr oder weniger komplizierten
Versuchen habe ich dafür eine im Detail trickreich zu entwickelnde
aber erstaunlich einfach zu bedienende Möglichkeit gefunden, die sich
nahtlos in das vorhandene Konzept eingegliedert hat.

Darüber hinaus habe ich meine langjährige Erfahrung in der Entwicklung
und nicht zuletzt auch Fehlerbereinigung von Software eingebracht um
im gesamten Projekt kleinere beobachtete Bugs aufzuspüren und gleich
zu beseitigen (``I've got a debugger and I'm not afraid to use it!'').
Auch war ich in fast allen Reviews als Gutachter tätig.

Da zu keinem Zeitpunkt des Projektes die Zielhardware existiert hat,
mußte die komplette Entwicklung der Software ``im Trockenen'' 
stattfinden. Erst ganz gegen Ende des Projektes hatten wir zumindest 
Zugriff auf ein Altera Excalibur CPLD Entwicklerboard mit einem Apex 
EP20K200 Baustein, wobei mir die Aufgabe zugefallen ist unser Projekt 
und dieses Board zu verheiraten. 
Zu diesem Zweck habe ich mich noch mit CPLDs im Allgemeinem sowie mit 
dem Entwicklerboard und der CPLD Entwicklungsumgebung Quartus II 
im Speziellem vertraut gemacht und verschiedene NIOS Prozessordesigns 
implementiert und getestet. Dabei zeichnete ich mich für verschiedene
kleinere POA Änderungen verantwortlich, deren Notwendigkeit sich erst 
in der Praxis ergab.

Last and probably least war ich partiell an der Einführung von
CPPUnit, der Erstellung des Handbuchs sowie des Abschlussberichts
beteiligt.

\subsection{Team}
Das Team hat sich erfreulicherweise als überaus kompetent erwiesen,
eine Eigenschaft, die leider auch in höheren Semestern der
Softwaretechnik nicht immer selbstverständlich ist. Auch
zwischenmenschlich sind mir keinerlei Probleme aufgefallen, im
Gegenteil. Die Team-Größe war der Aufgabenstellung angemessen.

Das Team war größtenteils sehr motiviert und auch das Projekt
Management hat sehr gut funktioniert. Alles in allem eine sehr
willkommene Abwechslung zu meinem in fast all diesen Punkten etwas
gescheitertem StuPro A.

\subsection{Fazit}
Meine Erachtens war das Projekt ein voller Erfolg, die Vorgaben wurden
laut des Kunden zur vollsten Zufriedenheit erfüllt. Das Arbeitsklima
war durchweg angenehm und der verwendete Software-Prozess war den
leicht ungenauen, aufgrund der weitergehenden Forschung teilweise auch
dem Kunden noch nicht hundertprozentig bekannten Anforderungen
gewachsen.

\newpage
\section{Steffen Pingel}

\begin{center}
\includegraphics[width=5cm]{Fotos/steffen_p}
\end{center}

\subsection{Aufgaben}

Ich habe vielfältige Aufgaben während des POA Projekts übernommen. In
erster Linie war ich als Projektleiter für das Management des Projekts
und dessen erfolgreichen Abschluss verantwortlich. Ich habe mich
bemüht, im Sinne des Management-By-Objectives, Ziele zu setzen, das
Team zu koordinieren und nur zu führen, wenn es notwendig war. In
diesem Zusammenhang habe ich mich in meinem Seminarvortrag zu dem
Thema ``Extreme Programming'' mit agilen Vorgehensmodellen beschäftigt
und viele Ideen und Konzepte in die Umsetzung des POA Projekts
einfließen lassen.

Das Team war aus sehr unterschiedlichen Mitgliedern zusammen gesetzt.
Mir waren zu Projektbeginn nur zwei Mitglieder persönlich bekannt. Die
Fähigkeiten, Stärken und sehr unterschiedlichen Arbeitsweisen der
anderen Teilnehmer lernte ich erst während des Projekts kennen.
Erschwerend kam hinzu, dass der Erfahrungshorizont innerhalb des Teams
sehr unterschiedlich ausgeprägt war. Vier von den sieben Mitgliedern
hatte zu Beginn des POA Projekts noch kein, wie im Studienplan
eigentlich ausdrücklich gefordert, Studienprojekt begonnen. Wohingegen
die anderen drei, zu denen auch ich gehörte, bereits ein
Studienprojekt zur Hälfte absolviert hatte.

Die Organisation umfasste sowohl die Vereinbarung von gemeinsamen Team
Terminen als auch die Kommunikation mit den einzelnen Entwicklern. Die
Verteilung der Aufgaben und die Kontrolle der Umsetzung wurde
gemeinsam bei Treffen des Teams vorgenommen. Jeder Entwickler hat zu
Anfang des Treffens einen kurzen Überblick über den Fortschritt seit
dem letzten Treffen gegeben und eine Einschätzung abgegeben, wieviel
Zeit bis zur Erfüllung der Aufgabe vorraussichtlich noch benötigt
wurde. Diese persönlichen Zeitschätzungen waren vor allem zu Anfang
des Projekts oft zu optimistisch, wurden aber zunehmend besser, so
dass die Planung zu Ende des Projekts präziser vorgenommen werden
konnte.

Im Laufe des Projekts habe ich neben der Organisation zahlreiche
produktive Tätigkeiten übernommen. Ich habe mich an der Verfassung des
Angebots beteiligt, sowie den Entwurf mitgestaltet. Während der
einzelnen Iterationen habe ich mich bemüht meinen Anteil an der
Kodierung möglichst weit einzuschränken. Zum einen stand eine
ausreichende Anzahl von guten Entwicklern im Team zur Verfügung und
zum anderen war der organisatorische Anteil, den ich zum größten Teil
erledigt habe, höher als erwartet.

Die größte einzelne Komponente, die ich entwickelt habe, ist die
Konsistenzprüfung eines Projekts. Dazu war es notwendig mittels
einfachem rekursivem Abstieg die Verbindungen zwischen den Blöcken zu
prüfen und einen Ergebnisbericht zu erzeugen. Desweiteren habe ich
die Settings Klasse implementiert, die globale Einstellungen der
Anwendung verwaltet. Die von mir erstellte Bibliothek zur Speicherung
von vorgefertigten Blöcken macht starken Gebrauch der bereits für die
Projektverwaltung implementierten Serialisierung, so dass ich hier im
wesentlichen die graphische Schnittstelle erstellt habe. 

Maßgeblich habe ich mich um die Umsetzung des Tests bemüht. Das
Interesse der Entwickler an Tests war erwartungsgemäß nicht besonders
hoch. Angesichts des hohen Anteils an schwierig automatisiert
testbaren GUI Quellcodes verständlich. Der Test bestand aus einer
Suite von automatisierten Regression-Tests, die vorwiegend von mir
erstellt wurden. Die Qualität der Tests wurde anhand der
Anweisungsüberdeckung mit dem Werkzeug gcov gemessen.

Die Ausgabe von gcov wurde mit GCover graphisch als HTML Seiten
aufbereitet. GCover ist als Teilprojekt von POA entstanden (siehe auch
\ref{gcover} und orientiert sich an anderen Werkzeugen zur Messung der
Testüberdeckung, von denen allerdings kein kostenloses zur Auswertung
der gcov Asugabe zur Verfügung stand. Ich habe GCover zusammen mit
Tammo van Lessen entwickelt. Tammo van Lessen und ich haben bereits in
anderen Softwareprojekten erfolgreich zusammen gearbeitet und verfügen
beide über eine fundierte Erfahrung mit der Sprache Java. Dadurch
konnten wir GCover in kurzer Zeit fertigstellen ohne unsere
Kernaufgaben innerhalb des POA Projekts zu vernachlässigen.

\subsection{Fazit}

Besonderen Wert habe ich auf die Anwendung der im
Softwaretechnik-Studium erworbenen Kenntnisse gelegt. Auch auf Grund
von Erfahrungen aus einem vorherigen Studienprojekt war es mir wichtig
den Fokus nicht ausschließlich auf den Umfang des Produkts zu legen,
sondern vor allem auch die Qualität und das Vorgehensmodell zu
beachten.

Mir ist deutlich geworden wie wichtig es ist sich als
Softwareentwickler in die Problemdomäne des Kunden einzuarbeiten. Ohne
Verständnis für die mit POA zu programmierende Hardware, wäre es
nicht möglich gewesen ein sinnvolles Bedienkonzept zu entwickeln. Es
hat auch die Kommunikation mit dem Kunden erleichtert, dass ich, wie die
anderen Teammitglieder, bereits Vorlesungen der Automatisierungstechnik
besucht hatte und mit dem Umfeld der Werkzeugmaschinen vertraut war.

Auf Seite der Softwaretechnik habe ich viel über den Aufwand und die
Schwierigkeiten der Organisation von Softwareprojekten gelernt. Es war
eine größere Herausforderung als erwartetet sieben Entwickler so zu
koordinieren, dass eine produktive Teamdynamik entsteht, alle
Entwickler ausreichend gefordert und ausgelastet sind. Über 1000
E-Mails, die im Zusammenhang mit dem POA Projekt verschickt wurden,
bestätigen meinen positiven Eindruck der lebhaften, kommunikativen
Atmosphäre des Projekts, die sich auch in sozialen Aktivitäten
außerhalb der Universität äußert.

Abschliessend beurteile ich das Projekt als Erfolg. Alle Team
Mitglieder haben sich bemüht das im Studium erworbene Wissen praktisch
umzusetzen. Im Verlaufe des Projekts hat sich eine tolle Teamdynamik
entwickelt. Das gewählte Vorgehensmodell erscheint mir den besonderen
Anforderungen eines Studienprojekts gerecht zu werden. Die
Kommunikation mit unserem Kunden Christian Kramer war sehr kooperativ.
Das entstandene Produkt erfüllt die Anforderungen des Kunden und 
entspricht qualitativ meinen Erwartungen.

\newpage
\section{Tammo van Lessen}

\begin{center}
\includegraphics[width=5cm]{Fotos/tammo}
\end{center}

\subsection{Aufgaben}

Der Abschnitt Studienprojekt B begann für mich mit der Auswahl eines
der angebotenen Projekte. Beide schienen mir sehr interessant, ich
entschied mich jedoch für das Projekt POA, da es eine interessante
Zusammenspiel zwischen Software und Hardware darstellt, für die ich
mich schon früher begeistern konnte.

\subsection{Tätigkeiten}

\subsubsection{Seminar}

So lag es nahe, dass ich als Thema für das Seminar die Programmierbare
Logik wählte. Ziel des Vortrags war es aufzuzeigen, welche Arten der
programmierbaren Logik es gibt und auf welche Weise sie
funktioniert. Dazu befasste ich mich mit der Geschichte der
Halbleitertechnologie, ging von den Fullcustom ICs über die Semicustom
ICs zur dynamischen Verdrahtung in ICs über und beendete die Reise bei
komplexen System on a Chip Lösungen. Auf dem Weg ging ich jeweils auf
die Speichertechnologien sowie die logische Darstellung der Funktion
auf dem Chip ein. Zum Abschluß stellte ich den Altera CPLD-Chip \emph{APEX
20k} und dessen eingebettete CPU \emph{NIOS} kurz vor. Diese beiden
Komponenten kommen bei dem POA Projekt auf der Hardwareseite zum Einsatz.

\subsubsection{Aufgaben}
Nachdem der Projektplan erstellt war, war es meine Aufgabe, die
Anforderungen an das Projekt grob zu ordnen und in einer projektinternen
Spezifikation festzuhalten. Daran angeknüpft nahm ich an einem Review
des Entwurfs teil, welches produktiv einige Ver\-besserun\-gen ermöglichte
und somit ein schlanker aber leistungsfähiger Entwurf entstand.

An der darauf folgenden Implementierungsphase war ich fast über die
gesamte Laufzeit beteiligt. Zu Beginn erstellte bzw. erweiterte ich
das Datenmodell und das Projektmanagement und war für die Persistenz
der Daten zuständig. Dazu verwendete ich das von Qt zur Verfügung
gestellte XML DOM-Framework. Die Persistierung der Daten habe ich so
angelegt, dass jedes Objekt sich selbst in eine XML-Struktur schreiben
kann und umgekehrt aus einer XML-Struktur seinen Zustand wieder
herstellen kann.

Weiterhin übernahm ich den von Marcel begonnenen Scheduling-Dialog und
führte ihn zum jetzigen Stand. Dazu implementierte ich die
Darstellung der Blöcke deren Länge der Taktrate und deren Position auf
der X-Achse das Zeit-Offset darstellt. Wenn es eine Verbindung, also
eine Signalabhängigkeit zwischen zwei Blöcken gibt, so wird eine
gerichtete Kante zwischen den beiden Blöcken gezeichnet. Damit die
Grafik besser zu erkennen ist, habe ich eine Zoomfunktion
implementiert. Zusätzlich wird dem Benutzer eine Art Lineal angezeigt,
die ihm die aktuelle Position auf der Zeitachse zeigt.

Neben vielen kleineren Verfeinerungen die ich an der GUI vornahm
(Farbpalette, Einfärben der Blöcke nach Taktraten, 3D-Effekte) startete
ich das Unterprojekt GCover. GCover verarbeitet die Ausgabe des GNU
Compilertools gcov und erstellt daraus eine HTML-Suite die die
Anweisungsüberdeckung bei der Ausführung von Testfällen
visualisiert. Die Messung dieser Überdeckung selbst übernimmt
gcov. Zusammen mit Steffen wurde dieses Werkzeug parallel zur POA
Implementierung fertiggestellt und für die Veranschaulichung der
Testüberdeckung angewendet.

Am Ende der ersten Iteration analysierten Steffen, Anselm und ich die
Entwurfstreue und die Architekturqualität des entstandenen Quellcodes
und definierten daraus einige Refactoring-Maßnahmen. Das hat sich in
einigen Punkten ausbezahlt. So konnten wir einige Verstöße gegen das
Model-View-Controller-Konzept finden und beheben. Ausserdem sind uns
bei einige Redundanzen im Datenmodell aufgefallen, die wir dann
entfernen konnten. Für dieses Treffen erstellte ich ein UML-Diagramm
welches die POA-Architektur veranschaulicht. Die aktuelle Version
dieses Diagramms wird zum Projektende als DIN A1 Plakat zusammen mit
einem Entwurfsdokument ausgeliefert, welches ich mitgestaltete.

Zum Abschluß der Implementierungsphase nahm ich an Code-Reviews von
ausgewählten Komponenten teil. Auch hier konnten wir einige
Kleinigkeiten und potentielle Fehler finden.

Die Projekthomepage, zu finden unter http://poa.berlios.de wurde
ebenfalls von mir konfiguriert und informiert den Besucher über die
aktuelle Projektentwicklung. So sind dort Metriken, CVS Statistiken,
API sowie die projektbegleitende Dokumentation zu finden. Die Homepage
wird dazu mit Maven generiert.



\subsection{Team}
Zu Beginn des Projekts waren mir nur drei der sieben Teammitglieder
bekannt. So war es mir nicht möglich die Qualifikation und Motivation
des Team abzuschätzen oder gar den Projekterfolg vorherzusagen. Es hat
sich aber schnell herausgestellt, das sich ein sehr kompetentes Team
gefunden hat. Besonders positiv ist mir die unkomplizierte
Kommunikation im Team aufgefallen. Das Arbeitsklima bei den
Kernarbeitszeittreffen waren immer sehr gut. So konnten wir uns
jederzeit sehr gut absprechen. So kam es kaum vor, dass Schnittstellen
falsch bedient wurden etc.

\subsection{Persönlicher Lernerfolg}
Für mich persönlich war das Projekt eine neue Herausforderung, war es
doch für mich das erste Studienprojekt und damit auch das erste
Projekt dieser Größe. Hinzu kam, dass mir sowohl die
Programmiersprache C++ sowie das Toolkit Qt bis dato unbekannt waren
und ich mich selbst nicht besonders gut einschätzen konnte.
Was ich jedoch schnell gelernt habe: Wenn man die Konzepte des
objektorientieren Programmierens verstanden hat, ist es eher zweitrangig, 
in welcher Sprache man implementiert. Die Besonderheiten von
C++ konnte ich relativ schnell lernen, nicht zuletzt Dank der guten
Teamdynamik. Auch in die Qt-Bibliothek konnte ich mich schnell
eingewöhnen. Lerneffekt hier war, dass nicht alles, was als toll
angepriesen wird, auch uneingeschränkt toll ist. So sind beispielsweise
bei Qt die APIs nicht immer konsistent, ausserdem sind die
GUI-Komponenten teilweise nicht bis zum Ende durchdacht. Die
Qt-Spezialität \emph{Signal \& Slots}, die eine Einbettung des
Observer-Patterns in die Programmiersprache ist, ermöglicht sehr
einfache autonome Objekt-Benachrichtigungen, allerdings kann man
schnell den Überblick verlieren.

Neben diesen technischen Dingen lernte ich aber auch einiges über das
zwischenmenschliche Miteinander in einem Projekt dieser Größe, Vor-
und Nachteile von iterativen Entwicklungsprozessen und wie wichtig
eine klare und offene Kommunikation ist. Letzteres ist mir jedoch
nicht direkt bei diesem Projekt aufgefallen. Das deutet auf einen
optimales Arbeitsklima hin.

Somit sehe ich das Projekt aus meiner Sicht als Erfolg.

\appendix

\chapter{Erklärung gemäß Prüfungsordnung}

Ich erkläre hiermit, dass ich im Rahmen meiner Mitarbeit am
Studienprojekt B ``Programmierumgebung Offener Antrieb'' außer von den
Betreuern vorgesehenen bzw. genehmigten Hilfsmitteln keine unzulässige
Hilfe in Anspruch genommen habe.

\vspace{2cm}
Stuttgart, den 17. Juni 2004
\vspace{2cm}

\begin{center}
\begin{tabular}{ccc}
  \hspace{5cm} & \hspace{5cm} & \hspace{5cm} \\
  \hhline{-~-} Necati Aydin & & Anselm Garbe \\
  \vspace{2cm} \\
  \hhline{-~-} Stefan Hauser & & Steffen Keul \\
  \vspace{2cm} \\
  \hhline{-~-} Marcel Kilgus & & Steffen Pingel \\
  \vspace{2cm} \\
  \hhline{-~~} Tammo van Lessen \\
\end{tabular}
\end{center}

\end{document}
