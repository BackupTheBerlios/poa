%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro B, "Programmierumgebung Offener Antrieb" (POA)
%% Anforderungen
%% $Id: anforderungen.tex,v 1.3 2003/05/31 19:11:34 garbeam Exp $
%% Achtung: Diese Datei wird ins Angebot inkludiert!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Anforderungen
\chapter{Anforderungen}
Dieses Kapitel beschreibt die Anforderungen des Kunden an das
Studienprojekt B, ''Programmierumgebung Offener Antrieb'' (POA).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hintergrund
\section{Hintergrund}
Es werden viele Neuentwicklungen im Bereich der Werkzeugmaschinen gemacht.
Viele dieser Entwicklungen beinhalten neue Kinematiken, wie z.B. die
Parallelkinematiken und Sensoren (z.B. den Ferraris 
Relativbeschleunigungssensor).\par
Dadurch entstehen neue Anforderungen an die Antriebsregelung. Zusätzliche
Sensor-Signale müssen in den Reglerstrukturen berücksichtigt werden - oder
sogar völlig neue Reglerstrukturen werden benötigt.\par
Die momentan auf dem Markt erhältlichen Reglersysteme erlauben meist
weder die Berücksichtigung neuartiger Sensoren, noch bieten sie die
Möglichkeit, eigene anwenderspezifische Reglerstrukturen zu implementieren.\par
Daher wird am ISW eine Plattform für die Antriebsregelung entwickelt,
auf der es dem Anwender in jeder Hinsicht offen steht, eigene Funktionalitäten
zu integrieren. Diese Plattform wird am ISW kurz als ``Offener Antrieb''
bezeichnet.  \par
Die hardwaretechnische Realisierung erfolgt in Form einer PC-Einsteckplatine.
Zentrales Element des Offenen Antriebes ist der Altera ``APEX''Baustein. Es
handelt sich dabei um einen CPLD\footnote{Complex Programmable Logic Device},
der sich frei programmieren lässt. Der Anwender hat die Möglichkeit, die
Funktion des Bausteins seinen Bedürfnissen anzupassen.\par
Um die Offenheit für jeden Anwender nutzbar zu machen, wird für den CPLD eine
Architektur festgelegt, die es ermöglicht, einzelne Funktionalitäten in Form
von Modulen zu implementieren. Diese Modlue können aus festprogrammierten
Schaltungen (Cores) und freiprogrammierbaren CPUs bestehen. Jedes Modul kann
auf die Signale aller anderen Module zugreifen und stellt seine eigenen
Ausgangsignale allen anderen Modulen zur Verfügung.\par
Inhalt dieses Angebotes ist es, eine Programmierumgebung für das Netzwerk
von CPUs und Cores zu schaffen, in dem ein bereits auf dem CPLD vorhandenes
Netzwerk konfiguriert werden kann.\par
Die detaillierten Anforderungen der hiermit angebotenen Programmierumgebung
``Offener Antrieb`` erschliessen sich nur aus dem Zusammenhang des im Folgenden
dargelegten Kataloges der Funktionalen Anforderungen. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionale Anforderungen
\section{Funktionale Anforderungen}

Die Programmierumgebung ``Offener Antrieb`` soll eine grafisch Oberfläche
mit folgenden wesentliche Funktionalitäten bieten:
\begin{itemize}
\item Darstellung und Manipulation rasterisierter CPLD Layouts
\item Verwaltung und Editierung einer CPLD-Modulbibliothek zur CPLD-Layout
      Manipulation
\item Rahmencodegenerierung für eingebette CPU-Module in einem CPLD-Layout
\item Plausibilitätsprüfung und Optimierung eines entworfenen CPLD-Layouts
\item Compilieren und Herunterladen eines fertiggestellten CPLD Layouts
\item Speichern und Öffnen von CPLD-Layouts und zugehörigen Sourcen
\item Konfiguration der Programmeigenschaften
\item Zusammenarbeit mit externen Programmen
\end{itemize}
Auf die Einzelheiten der wesentlichen Funktionalitäten und der Abgrenzung der
aufgeworfenen Begriffe wird in den folgenden Abschnitten eingegangen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD Layouts
\subsection{CPLD Layouts}
Ein CPLD Layout spiegelt ein virtuelles Abbild der realen Konfiguration
(Vernetzung der CPLD-Funktionsblöcke) eines CPLD Hardware-Bausteins wider.
Dabei besteht die virtuelle Abbildung aus Funktionsblöcken (CPU, Cores,
E/A-Blöcke) und Signalleitungen.\par
Im zu entwickelnden System soll ein CPLD Layout rasterisiert dargestellt
werden und durch Maus- und Tastatureingaben manipulierbar sein. Dabei
werden Funktionsblöcke mit der Maus in ein Raster eingebettet und durch
einzelne Linien, die die Signalleitungen symbolisieren, verbunden.
Die Funktionsblöcke selbst sollen konfigurierbar und editierbar sein.\par
CPLD-Layouts sollen XML-basiert speicher- und ladbar sein. Sie werden
zusammen mit dem zugehörigen Source- und evtl. vorhandenen Object-Code
in einer geeigneten Verzeichnisstruktur abgelegt.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CPLD-Modulbibliothek
\subsection{CPLD-Modulbibliothek}
Die Modulbibliothek ist eine CPLD-Layout übergreifende Sammlung von
Funktionsblöcken (CPU, Cores, E/A-Blöcke), die in CPLD-Layouts einbettbar
sein sollen. Bereits vorhandene, in CPLD-Layout eingebettete Funktionsblöcke,
die umkonfiguriert oder editiert wurden (z.B. spezieller Code in einem
CPU-Block), und demnach noch nicht in der Modulbibliothek existieren,
sollen in die Modulbibliothek exportierbar sein.\par
Funktionsblöcke sollen CPLD-Layout-unabhängig aus der Modulbibliothek
entferbar, editierbar und umkonfigurierbar sein (mit Ausnahme der drei
Grundfunktionsblöcke).\par
Die Modulbibliothek soll permanent gespeichert werden und bei jedem
Systemaufruf automatisch geladen werden. Eine Verwaltung verschiedener
Modulbibliotheken wird nicht angeboten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Funktionsblock
\subsection{Funktionsblock}
Ein Funktionsblock spiegelt ein virtuelles Abbild eines CPU-, Core- oder
E/A-Bausteins auf einem CPLD wider. Dabei sollen an allen genannten
Funktionsblöcken die Ein- und Ausgänge mit Signalleitungen verbunden
werden können.\par
Speziell bei CPU-Blöcken soll überdies die Anzahl der Ein- und Ausgänge,
die Benennung der E/As, das Einstellen eines Zeitoffsets, das Setzen
einer logischen Taktrate konfigurierbar sein und der auf dem jeweiligen
CPU-Block auszuführende Sourcecode editierbar sein.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Rahmencodegenerierung
\subsection{Rahmencodegenerierung}
Zur Editierung von C-Sourcen für CPU-Blöcke soll ein (vom Kunden)
vordefiniertes C-Template kontextabhängig für die existierende
Konfiguration eines CPU-Blocks verwendet werden, um Rahmencode zu generieren.
Dabei soll die Benamung der Signal-Ein- und Signal-Aus-gänge im C-Sourcecode
eines einzelnen CPU-Blocks angepaßt werden. Hierzu wird lediglich ein
einfacher Substitutionsalgorithmus ohne tierfergehende Logik angeboten.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plausibilitätsprüfung
\subsection{Plausibilitätsprüfung}
Die Vernetzung von Funktionsblöcken in einem entworfenen CPLD-Layout soll
auf ihre Plausibilität geprüft werden können, im Einzelnen:
\begin{itemize}
\item Prüfung auf unverknüpfte E/As
\item Prüfung auf falsch verknüpfte E/As (E-E, etc.)
\end{itemize}
Sofern das entworfene CPLD-Layout Ungereimtheiten aufweist, soll eine
Warnmeldung ausgegeben werden, die die fehlerhaften Verknüpfungen aufführt.\par


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Optimierung
\subsection{Optimierung}
Der Entwurf eines plausiblen CPLD-Layouts soll durch einen gekoppelten
Signallaufzeitsermittlungs- und -optimierungs-Algorithmus optimiert werden
können. Hierzu wird zur Laufzeitermittlung ein Laufzeitermittlungsprogramm
für CPLD-CPU-Block Object-Code verwendet, das vom Kunden zu liefern ist.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Compilieren und Herunterladen
\subsection{Compilieren und Herunterladen}
Einzelne Funktionsblöcke eines plausiblen CPLD-Layouts und gesamte plausible
CPLD-Layouts sollen durch einen externen Compiler compiliert werden können,
der vom Kunden zu liefern ist.\par
Weiterhin soll ein plausibles und vollständig compiliertes CPLD-Layout auf
den CPLD heruntergeladen werden können. Um diese Anforderung umsetzen zu 
können, hat der Kunde die Schnittstelle sowie ein Beispielprogramm zu liefern.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Externe Programme
\subsection{Externe Programme}
Zur Editierung von Sourcecode, zum Compilieren von Sourcecode, zum
Herunterladen von Object-Code und zur Laufzeitbestimmung sollen externe
Programme eingesetzt werden.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Konfiguration
\subsection{Konfiguration}
Es soll der externe Editor, der externe Compiler der Pfad zum C-Souce
Template und das externe Download-Tool konfigurierbar sein.

